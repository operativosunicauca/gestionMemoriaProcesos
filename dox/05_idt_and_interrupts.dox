/**
@page idt_page IDT y Gestión de Interrupciones
@author Erwin Meza Vega <emezav@gmail.com>

@ref project_start : @ref ia32_intro : IDT y Gestión de Interrupciones

Una interrupción es una señal que rompe con el flujo normal del procesador, y 
que debe ser atendida inmediatamente.  

@par Fuentes de Interrupción

En la arquitectura IA-32 se definen tres fuentes básicas de interrupción:
- Excepciones: Son condiciones de error que se presentan en la ejecución. Por 
  ejemplo, al realizar una división por cero se lanza la excepción Division By
  Zero. Es una interrupción generada internamente por el procesador.
- Interrupciones de los dispositivos de hardware (discos, teclado, floppy, etc).
  Los dispositivos de hardware realizan solicitudes de interrupción (Interrupt
  Request - IRQ). Cada IRQ tiene asociado un número de interrupción predefinido,
  pero es posible cambiarlo por programación.
- Interrupciones por software, generadas mediante la instrucción
@verbatim
  int N
@endverbatim
  donde N es el número de interrupción.

La arquitectura IA-32 soporta 256 interrupciones. De estas, las 32 primeras 
(número 0 a 31) se asignan por defecto a las excepciones del procesador. 

A continuación se muestra una descripción de las interrupciones para IA-32.

@verbatim
Número de    | Descripción
Interrupción |
(dec/hex)    |
-------------|-------------------------------------------------
  0  0x00    | Divide error:
             | Ocurre durante una instrucción DIV, cuando el divisor
             | es cero o cuando ocurre un desbordamiento del cociente.
             | Esta excepción no genera código de error.

  1  0x01    | (Reservada)
             | Esta excepción no genera código de error.  

  2  0x02    | Nonmaskable interrupt:
             | Ocurre debido a una interrupcion de hardware que no se puede
             |  enmascarar.
             | Esta excepción no genera código de error.

  3  0x03    | Breakpoint:
             | Ocurre cuando el procesador encuentra una instrucción INT 3
             | Esta excepción no genera código de error.

  4  0x04    | Overflow:
             | Ocurre cuando el procesador encuentra una instrucción INTO
             | y el bit OF (Overflow) del registro EFLAGS se encuentra activo.
             | Esta excepción no genera código de error.

  5  0x05    | Bounds check (BOUND instruction):
             | Ocurre cuando el procesador, mientras ejecuta una instrucción
             | BOUND, encuentra que el operando excede el límite especificado.
             | Esta excepción no genera código de error.

  6  0x06    | Invalid opcode:
             | Ocurre cuando se detecta un código de operación inválido.
             | Esta excepción no genera código de error.

  7  0x07    | Device Not Available (No Math Coprocessor)
             | Ocurre para alguna de las dos condiciones:
             | - El procesador encuentra una instrucción ESC (Escape)
             |   y el bit EM (emulate) bit de CR0 (control register zero)
             |   se encuentra activo.
             | - El procesador encuentra una instrucción WAIT o una instrucción
             |   ESC y los bits MP (monitor coprocessor) y TS (task switched)
             |   del registro CR0 se encuentran activos.
             | Esta excepción no genera código de error.

  8  0x08    | Double fault:
             | Ocurre cuando el procesador detecta una excepción mientras trata
             | de invocar el manejador de una excepción anterior.
             | Esta excepción genera un código de error.

  9  0x09    | Coprocessor segment overrun:
             | Ocurre cuando se detecta una violación de página o segmento
             | mientras se transfiere la porción media de un operando de 
             | coprocesador al NPX.
             | Esta excepción no genera código de error.

 10  0xA     | Invalid TSS:
             | Ocurre si el TSS es inválido al tratar de cambiar de tarea (Task 
             |  switch).
             | Esta excepción genera código de error.

 11  0xB     | Segment not present:
             | Ocurre cuando el procesador detecta que el bit P (presente) de un
             | descriptor de segmento es cero.
             | Esta excepción genera código de error.

 12  0xC     | Stack exception:
             | Ocurre para las siguientes condiciones:
             | - Como resultado de una violación de límite en cualquier operación
             |   que se refiere al registro de segmento de pila (SS)
             | - Cuando se trata de establecer SS con un selector cuyo descriptor
             |   asociado se encuentra marcado como no presente, pero es válido
             | Esta excepción genera código de error.

 13  0xD     | General protection violation (GP):
             | Cada violación de protección que no causa otra excepción
             | causa una GP.
             | - Exceder el límite de segmento para CS, DS, ES, FS, o GS
             | - Exceder el límite de segmento cuando se referencia una tabla de
             |   descriptores
             | - Transferir el control a un segmento que no es ejecutable
             | - Escribir en un segmento de datos de sólo lectura o en un 
             |   segmento de código
             | - Leer de un segmento marcado como sólo de ejecución
             | - Cargar en SS un selector que referencia a un segmento de sólo 
             |   lectura
             | - Cargar SS, DS, ES, FS, o GS con un selector que referencia a un
             |   descriptor de tipo "sistema"
             | - Cargar DS, ES, FS, o GS con un selector que referencia a un 
             |   descriptor de segmento marcado como ejecutable que además no se
             |   puede leer
             | - Cargar en SS un selector que referencia un descriptor  de 
             |   segmento ejecutable
             | - Acceder a la memoria por medio de DS, ES, FS, o GS cuando estos
             |   registros de segmento contienen un selector nulo
             | - Pasar la ejecución (task switch) a una tarea marcada como "Busy"
             | - Violar las reglas de privilegios
             | - Cargar CR0 con los bits PG=1 y PE=0 (habilitar la paginación y
             |      no habilitar el modo protegido)
             | - Lanzar una interrupción o una excepción a través de un trap 
             |   gate desde Modo Virtual 8086 a un privilegio (DPL) diferente 
             |   de cero 
             | Esta excepción genera código de error.

 14  0xE     | Page fault:
             | Ocurre cuando la paginación está habilitada (PG = 1) en CR0
             | y el procesador detecta alguna de las siguientes condiciones
             | cuando trata de traducir una dirección lineal a física:
             | - El directorio de tabla de páginas o la tabla de páginas requerido
             |   para realizar la traducción tiene 0 en su bit de presente (P)
             | - El procedimiento actual no tiene los suficientes privilegios para
             |   acceder la página indicada.
             | Esta excepción genera código de error.

 15  0xF     | (Reservada)
             | Esta excepción no genera código de error.

 16  0x10    | x87 FPU Floating-Point Error (Math Fault)
             | Ocurre cuando el procesador detecta una señal del coprocesador en el
             | pin de entrada ERROR#.

 17  0x11    | Alignment Check
             | Ocurre cuando se realiza una referencia de datos en la memoria a 
             | una región no alineada.
             | Esta excepción genera código de error.
 
 18  0x12    | Machine Check
             | Depende del modelo y las características del procesador.
             | Esta excepción no genera código de error.
          
 19  0x23    | SIMD Floating-Point Exception
             | Ocurre cuando existe un error en las instrucciones SSE/SSE2/SSE3.
             | Esta excepción no genera código de error.
          

 20  0x24    | Reservadas por Intel.
  hasta      |
 31  0x1F    | Estas excepciones no generan código de error.
             |
             
              
 32  0x20    | Interrupción externa o interrupción invocada mediante la
  hasta      | instrucción INT N
 255 0xFF    | Estas interrupciones no generan código de error
 
 
@endverbatim
@note Tabla adaptada de Intel® 64 and IA-32 Architectures Software Developer's 
Manual Volume 3A: System Programming Guide, Part 1. Sección 5.3.1.

@section idt_structure Tabla de Descriptores de Interrupción (IDT)

La IDT es una estructura de datos que usa el procesador en el momento en que
ocurre la interrupción, y que debe estar configurada antes de habilitar las
interrupciones. Es una tabla que contiene una serie de entradas denominadas 
"descriptores", que definen entre otros parámetros la dirección de memoria
en la cual se encuentra cada rutina de manejo de interrupción.

El siguiente esquema muestra la IDT y las rutinas de manejo de interrupción
en memoria:

@verbatim

        +------------------------------+
        |                              |
        |                              |
        +------------------------------+
        | Rutina de manejo de          |<------+
        | interrupción 255             |       |
        +------------------------------+       |
        |                              |       |
        | ...                          |       |
        +------------------------------+       |
        | Rutina de manejo de          |       |
        | interrupción 2               |       |
        +------------------------------+       |
        | Rutina de manejo de          |<----+ |
        | interrupción 1               |     | |
        +------------------------------+     | |
        | Rutina de manejo de          | <-+ | |
        | interrupción 0               |   | | |
        +------------------------------+   | | |
        |                              |   | | |
        |                              |   | | |
        |                              |   | | |
        +------------------------------+   | | |
        | Descriptor de Interrupción   |<------+
        | 255                          |   | |  
        +------------------------------+   | |  
        | ...                          |   | |  
        |                              |   | |
        +------------------------------+   | |
        | Descriptor de Interrupción   |<----+
        | 1                            |   |
        +------------------------------+   |
        | Descriptor de Interrupción   |<--+
        | 0                            |
        +------------------------------+ <--- Inicio de la Tabla de Descriptores
        |                              |      de Interrupción (IDT)
        |                              |
        |                              |
        |                              |
        |                              |
        +------------------------------+         

@endverbatim

La IDT está conformada por 256 descriptores, uno para cada interrupción. Cada 
descriptor ocupa 8 bytes, y puede ser de uno de los siguientes tipos:
 - Task-Gate 
 - Interrupt-Gate
 - Trap-Gate

Cada entrada tiene el siguiente formato:

@verbatim

 31                23               15--FLAGS---------- 7                0
 +-----------------------------------+-+-----+---------+-----+---------+
 |                                   | |     | TYPE    |  (ALWAYS 0)   |
 |           OFFSET 31..16           |P| DPL |0 D 1 1 0|0 0 0 0 0 0 0 0| 4
 |                                   | |     |         |               |
 +-----------------------------------+-+-----+---------+---------------+
 |                                   |                                 |
 |            SELECTOR               |          OFFSET 15..0           | 0
 |                                   |                                 |
 +-----------------------------------+---------------------------------+

@endverbatim

En donde:
- Offset: Desplazamiento (offset) en el cual se encuentra la rutina de manejo 
        de interrupción (la dirección de memoria de la rutina) dentro de
        un segmento de código.
- Selector: Selector que referencia al descriptor de segmento de código en la 
        GDT dentro del cual se encuentra la rutina de manejo de interrupción.
- D		: Tipo de descriptor : (0=16 bits), (1=32 bits)
- FLAGS :  compuesto por los bits P (1 bit), DPL (2 bits) y TYPE (5 bits).
Para un interrupt gate, el valor de FLAGS es 0x8E = 10001110 (P = 1, DPL = 0,
D = 1) 

La dirección lógica segmento : offset que se obtiene del descriptor se traduce
a una dirección lineal. Si la paginación se encuentra deshabilitada (por 
defecto), la dirección lineal es la misma dirección física en la cual se 
encuentra la rutina que atenderá la interrupción.


@par Carga de la IDT

Para cargar la IDT se utiliza la instrucción de ensamblador
  @code 
  lidt ptr_addr
  @endcode
 
La instrucción idt toma el puntero y lo carga en el registro IDTR del 
procesador. ptr_addr corresponde a la dirección de memoria en la cual se 
encuentra una estructura de datos que describe la IDT. Esta estructura de 
datos se denomina 'puntero a la IDT', 'IDT Pointer'.

El puntero al IDT tiene el siguiente formato:
@verbatim
 47                  15              0
 +----------------------------------+
 |      base         |    límite    |
 +----------------------------------+

@endverbatim
 en donde:
 base = dirección lineal de la IDT, que corresponde a la dirección
 de memoria de IDT.

 límite = tamaño de la IDT en Bytes. Si la IDT tiene 256 entradas y el
 tamaño de cada entrada es de 8 bytes, el tamaño total de la IDT
 es de 2048 bytes (2 KB).

@section interrupt_handling Gestión de Interrupciones en IA-32

Cuando ocurre la interrupción N, el procesador busca la entrada N dentro de
la IDT, y de ella obtiene la dirección lineal de la rutina de manejo de
la interrupción N a la cual se debe pasar el control.

Antes de pasar el control a la rutina de manejo de interrupción, el procesador
almacena en el tope de la pila el valor de EFLAGS, CS y EIP en este orden. Esto
permitirá ejecutar la rutina de manejo de interrupción y luego continuar la 
ejecución en el punto exacto en el que se interrumpió al procesador.

Si la interrupción genera un código de error (algunas de las excepciones de 
IA-32), este código de error también se inserta en la pila.

A continuación se ilustra el estado de la pila en el momento de pasar el control
a la rutina de manejo de interrupción.

-# Cuando ocurre una interrupción que no tiene código de error:
@verbatim

      Estado de la pila en el momento  de pasar el control a la rutina de manejo
      de interrupción

      +--------------------+    
      |  valor             |                                       
      +--------------------+ <- SS: ESP antes de ocurrir la interrupción
      | EFLAGS             |    
      +--------------------+     
      | CS                 |     
      +--------------------+
      | EIP                |  
      +--------------------+ <- SS: ESP al momento de pasar el control a la 
      | Espacio            |   rutina de manejo de interrupción
      | disponible en la   |
      | pila               |  
      |                    |
      |                    |
      +--------------------+ <---  Base de la pila
      |                    |
      |                    |
      +--------------------+
@endverbatim
Si el segmento de código en el cual se encuentra la rutina de manejo de 
interrupción tiene un nivel de privilegios (DPL) diferente al nivel de 
privilegios del segmento de código en el que se encuentra el código 
interrumpido, ocurre un "Cambio de Contexto" de pila. El procesador almacena 
primero SS y ESP, y luego almacena EFLAGS, CS e IP en la pila. 
@verbatim

    +--------------------------+
    | valor en la pila         | Pila del código (o tarea) antes de ocurrir la
    |--------------------------| interrupción o excepción                  
    | valor en la pila         |            
    +--------------------------+  <-- OLD SS: OLD ESP --+
                                                        |
                                                        |
 +------------------------------------------------------+
 |  +--------------------------+
 |  | old ss                   | Estos valores son almacenados automáticamente
 |  |--------------------------| en la pila cuando ocurre una interrupción
 +--|--> old esp               | o excepción y hay cambio de privilegios
    |--------------------------| ..
    | eflags                   | ..
    |--------------------------| ..
    | old cs                   | ..
    |--------------------------| ..
    | old eip                  | ..
    +--------------------------+  <-- ESP

@endverbatim
-# Cuando ocurre una interrupción que tiene código de error asociado:
@verbatim

      Estado de la pila en el momento  de pasar el control a la rutina de manejo
      de interrupción

      +--------------------+    
      |  valor             |                                       
      +--------------------+ <- SS: ESP antes de ocurrir la interrupción
      | EFLAGS             |    
      +--------------------+     
      | CS                 |     
      +--------------------+
      | EIP                |     
      +--------------------+
      | Código de error    |  
      +--------------------+ <- SS: ESP al momento de pasar el control a la 
      | Espacio            |        rutina de manejo de interrupción
      | disponible en la   |
      | pila               |  
      |                    |
      |                    |
      +--------------------+ <---  Base de la pila
      |                    |
      |                    |
      +--------------------+
@endverbatim
Si el segmento de código en el cual se encuentra la rutina de manejo de 
interrupción tiene un nivel de privilegios (DPL) diferente al nivel de 
privilegios del segmento de código en el que se encuentra el código 
interrumpido, ocurre un "Cambio de Contexto" de pila. El procesador almacena 
primero SS y ESP, y luego almacena EFLAGS, CS e IP en la pila. 
@verbatim

    +--------------------------+
    | valor en la pila         | Pila del código (o tarea) antes de ocurrir la
    |--------------------------| interrupción o excepción                  
    | valor en la pila         |            
    +--------------------------+  <-- OLD SS: OLD ESP --+
                                                        |
                                                        |
 +------------------------------------------------------+
 |  +--------------------------+
 |  | old ss                   | Estos valores son almacenados automáticamente
 |  |--------------------------| en la pila cuando ocurre una interrupción
 +--|--> old esp               | o excepción y hay cambio de privilegios
    |--------------------------| ..
    | eflags                   | ..
    |--------------------------| ..
    | old cs                   | ..
    |--------------------------| ..
    | old eip                  | ..
    |--------------------------| ..
    | Código de error          | ..
    +--------------------------+  <-- ESP

@endverbatim


Con el fin de mantener un marco de pila uniforme, se inserta un código de error
de cero en la pila para aquellas interrupciones que no generan codigo de error.

@section interrupt_handler_routines Rutinas de manejo de interrupción (ISR)

Las rutinas de manejo de interrupción son el elemento más cercano al hardware.
Estas rutinas deben interactuar directamente con los registros del procesador,
por lo cual se implementan en lenguaje ensamblador. Su tarea consiste en 
guardar el estado del procesador (el valor de todos sus registros), y luego
invocar el código en C que manejará la interrupción. Después se deberá 
recuperar el estado del procesador y retornar mediante la instrucción @b iret.

A continuación se presentan ejemplos de rutinas de manejo de interrupción.
- Rutina para el manejo de la interrupción 5 (no genera código de error)
@verbatim
isr5:
   /* Deshabilitar las interrupciones*/
 	cli
 	/* Ahora se crea un marco de pila estandar para invocar la rutina general
 	interrupt_dispatcher. */
 	/* Codigo de error = 0 */
	push 0
	/* # de excepcion generada */
	push 5 
	/* Almacenar en la pila los registros de propósito general en el siguiente
	orden: eax, ecx, edx, ebx, esp original, ebp, esi, y edi */
	pusha
	/* Almacenar en la pila los registros de segmento de datos */
	push ds
	push es
	push fs
	push gs

	/* Este marco de pila se crea en el contexto de ejecución actual. */

	/*
	La pila luce así:
	+--------------------------+
	| old SS                   |  (Si ocurre un cambio de contexto de pila)
	|--------------------------|  
	| old ESP                  |  (Si ocurre un cambio de contexto de pila)
	|--------------------------| ..
	| EFLAGS                   | Estos valores son almacenados automáticamente
	|--------------------------| en la pila cuando ocurre una interrupción
	| old CS                   | ..
	|--------------------------| ..
	| old EIP                  | ..
	|--------------------------| -------------------------------------------
	| 0 (código de error)      | push 0 (código de error = 0)
	|--------------------------|
	| # de excepción generada  | push \id
	|--------------------------|
	| EAX                      | pusha
	|--------------------------|
	| ECX                      |(recuerde que pusha almacena en la pila los
	|--------------------------|registros en el siguiente orden:
	| EDX                      |eax, ecx, edx, ebx, esp original, ebp, esi,
	|--------------------------|edi)
	| EBX                      |
	|--------------------------|
	| ESP antes de pusha       |
	|--------------------------|
	| EBP                      |
	|--------------------------|
	| ESI                      |
	|--------------------------|
	| EDI                      |
	|--------------------------|------------------------------------------
	| DS                       | ahora los registros de segmento de datos
	|--------------------------|
	| ES                       |
	|--------------------------|
	| FS                       |
	|--------------------------|
	| GS                       |
	|--------------------------|<-- ESP 
	*/

    /* Configurar los registros de segmento de datos para que contengan
	el selector de datos para el kernel definido en la GDT */
	movw ax, KERNEL_DATA_SELECTOR
	mov ds, ax
	mov es, ax
	mov fs, ax
	mov gs, ax
	
	/* Almacenar la posición actual del apuntador de la pila ss:esp */
	mov [current_ss], ss
	mov [current_esp], esp

	/* Invocar al código en C que manejará la interrupción */
	call interrupt_dispatcher
	
	/* Recuperar el apuntador de la pila ss:esp almacenado luego de crear
	el marco de pila para la interrupción */
	mov ss, [current_ss]
	mov esp, [current_esp]
	
	/* Ahora sacar los parámetros enviados a la pila en orden inverso */
	pop gs
	pop fs
	pop es
	pop ds
	/* los registros de propósito general */
	popa
	
	/* Código de error e interrupcion generada */
	add esp, 8

	/*
	Ahora la pila luce asi:
	+--------------------------+
	| old ss                   | Si ocurrió un cambio de contexto de pila,
	|--------------------------| se almacena la posición de la pila anterior
	| old esp                  | (SS:ESP).
	|--------------------------| 
	| eflags                   | Estado del procesador (EFLAGS)
	|--------------------------| 
	| old cs                   | Dirección lineal CS:EIP a la cual se debe
	|--------------------------| retornar (punto en el cual se interrumpió
	| old eip                  | el procesador)
	+--------------------------+ <-- ESP (tope de la pila)
	*/

	/* Retornar de la interrupcion */
	iret
	/* Esta rutina 'no retorna', ya que continua la ejecucion en el contexto
	que fue interrumpido. */
	
@endverbatim
- Rutina para el manejo de la interrupción 7 (genera código de error)
@verbatim
isr7:
   /* Deshabilitar las interrupciones*/
 	cli
 	/* Ahora se crea un marco de pila estandar para invocar la rutina general
 	interrupt_dispatcher. */
 	/* El código de error es almacenado  por el procesador en la pila
 	de forma automática cuando ocurre la excepcion
 	*/
	/* # de excepcion generada */
	push 7 
	/* Almacenar en la pila los registros de propósito general en el siguiente
	orden: eax, ecx, edx, ebx, esp original, ebp, esi, y edi */
	pusha
	/* Almacenar en la pila los registros de segmento de datos */
	push ds
	push es
	push fs
	push gs

	/* Este marco de pila se crea en el contexto de ejecución actual. */

	/*
	La pila luce así:
	+--------------------------+
	| old SS                   |  (Si ocurre un cambio de contexto de pila)
	|--------------------------|  
	| old ESP                  |  (Si ocurre un cambio de contexto de pila)
	|--------------------------| ..
	| EFLAGS                   | Estos valores son almacenados automáticamente
	|--------------------------| en la pila cuando ocurre una interrupción
	| old CS                   | ..
	|--------------------------| ..
	| old EIP                  | ..
	|--------------------------| -------------------------------------------
	| (código de error)        | push 0 (código de error = 0)
	|--------------------------|
	| # de excepción generada  | push \id
	|--------------------------|
	| EAX                      | pusha
	|--------------------------|
	| ECX                      |(recuerde que pusha almacena en la pila los
	|--------------------------|registros en el siguiente orden:
	| EDX                      |eax, ecx, edx, ebx, esp original, ebp, esi,
	|--------------------------|edi)
	| EBX                      |
	|--------------------------|
	| ESP antes de pusha       |
	|--------------------------|
	| EBP                      |
	|--------------------------|
	| ESI                      |
	|--------------------------|
	| EDI                      |
	|--------------------------|------------------------------------------
	| DS                       | ahora los registros de segmento de datos
	|--------------------------|
	| ES                       |
	|--------------------------|
	| FS                       |
	|--------------------------|
	| GS                       |
	|--------------------------|<-- ESP 
	*/

    /* Configurar los registros de segmento de datos para que contengan
	el selector de datos para el kernel definido en la GDT */
	movw ax, KERNEL_DATA_SELECTOR
	mov ds, ax
	mov es, ax
	mov fs, ax
	mov gs, ax
	
	/* Almacenar la posición actual del apuntador de la pila ss:esp */
	mov [current_ss], ss
	mov [current_esp], esp

	/* Invocar al código en C que manejará la interrupción */
	call interrupt_dispatcher
	
	/* Recuperar el apuntador de la pila ss:esp almacenado luego de crear
	el marco de pila para la interrupción */
	mov ss, [current_ss]
	mov esp, [current_esp]
	
	/* Ahora sacar los parámetros enviados a la pila en orden inverso */
	pop gs
	pop fs
	pop es
	pop ds
	/* los registros de propósito general */
	popa
	/* Código de error e interrupcion generada */
	add esp, 8

	/*
	Ahora la pila luce asi:
	+--------------------------+
	| old ss                   | Si ocurrió un cambio de contexto de pila,
	|--------------------------| se almacena la posición de la pila anterior
	| old esp                  | (SS:ESP).
	|--------------------------| 
	| eflags                   | Estado del procesador (EFLAGS)
	|--------------------------| 
	| old cs                   | Dirección lineal CS:EIP a la cual se debe
	|--------------------------| retornar (punto en el cual se interrumpió
	| old eip                  | el procesador)
	+--------------------------+ <-- ESP (tope de la pila)
	*/

	/* Retornar de la interrupcion */
	iret
	/* Esta rutina 'no retorna', ya que continua la ejecucion en el contexto
	que fue interrumpido. */
	
@endverbatim

La función interrupt_dispatcher puede ser implementada en C y contener el 
código para manejar las interrupciones.

Un punto clave de la implementación de la rutina es el siguiente:
@verbatim
    /* Almacenar la posición actual del apuntador de la pila ss:esp */
	mov [current_ss], ss
	mov [current_esp], esp

	/* Invocar al código en C que manejará la interrupción */
	call interrupt_dispatcher
	
	/* Recuperar el apuntador de la pila ss:esp almacenado luego de crear
	el marco de pila para la interrupción */
	mov ss, [current_ss]
	mov esp, [current_esp]
@endverbatim

Este código almacena en las variables globales del kernel current_ss y 
current_esp los valores de ss y esp, que permiten apuntar a la posición de 
la pila en la cual se almacenó el estado del procesador. Luego se puede invocar
a la función en C interrupt_dispatcher(). Esta función contendrá el código para
 manejar, y dado que current_ss y current_esp son variables globales, podrá
 tener acceso al estado del procesador en el momento en que ocurrió la 
 interrupción.

Cuando interrupt_dispatcher() retorna, se recupera el apuntador
a la pila en la posición en la cual se almacenó el estado del procesador.
De esa posición se recupera el estado de los registros a sus valores en el
momento en que ocurrió la interrupción, se extrae también el código de error.
@verbatim
/* Recuperar el apuntador de la pila ss:esp almacenado luego de crear
	el marco de pila para la interrupción */
	mov ss, [current_ss]
	mov esp, [current_esp]
	
	/* Ahora sacar los parámetros enviados a la pila en orden inverso */
	pop gs
	pop fs
	pop es
	pop ds
	/* los registros de propósito general */
	popa
	/* Código de error e interrupcion generada */
	add esp, 8
@endverbatim

Ahora en el tope de la pila se encuentra la posición de memoria a la cual
se debe retornar de la interrupción, y si ocurrió un cambio de contexto
de pila también se encuentra 

@verbatim
	+--------------------------+
	| old ss                   | Si ocurrió un cambio de contexto de pila,
	|--------------------------| se almacena la posición de la pila anterior
	| old esp                  | (SS:ESP).
	|--------------------------| 
	| eflags                   | Estado del procesador (EFLAGS)
	|--------------------------| 
	| old cs                   | Dirección lineal CS:EIP a la cual se debe
	|--------------------------| retornar (punto en el cual se interrumpió
	| old eip                  | el procesador)
	+--------------------------+ <-- ESP (tope de la pila)
@endverbatim

La instrucción 
@verbatim
iret
@endverbatim
Extrae el valor de EIP, CS y EFLAGS, y el valor de SS y ESP si ocurrió un 
cambio de contexto de pila. Con esto, la ejecución continúa exactamente
en el sitio en el cual fue interrumpido el procesador.   

@see idt.h Archivo con las definiciones necesarias para la gestión de 
     interrupciones
@see isr.S Archivo que contiene la implementación de las rutinas de
     manejo para las 256 interrupciones de IA-32
@see idt.c Archivo que contiene las rutinas para configurar y cargar la
     IDT y para gestionar las interrupciones.
@see @ref gdt_page
*/