<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Proyecto 10 - Gestión de Memoria Física: Creación y uso de rutinas</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Proyecto 10 - Gestión de Memoria Física
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">Aprendiendo Sistemas Operativos</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Buscar');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Página&#160;principal</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Páginas&#160;relacionadas</span></a></li>
      <li><a href="../../modules.html"><span>Módulos</span></a></li>
      <li><a href="../../annotated.html"><span>Estructuras&#160;de&#160;Datos</span></a></li>
      <li><a href="../../files.html"><span>Archivos</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Buscar" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Todo</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Estructuras de Datos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Archivos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Funciones</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>&apos;typedefs&apos;</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>&apos;defines&apos;</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Grupos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Páginas</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Creación y uso de rutinas </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Autor</dt><dd>Erwin Meza Vega <a href="#" onclick="location.href='mai'+'lto:'+'eme'+'za'+'v@g'+'ma'+'il.'+'co'+'m'; return false;">emeza<span style="display: none;">.nosp@m.</span>v@gm<span style="display: none;">.nosp@m.</span>ail.c<span style="display: none;">.nosp@m.</span>om</a></dd></dl>
<p><a class="el" href="../../index.html#project_start">Información del Proyecto</a> : <a class="el" href="../../d8/d50/ia32_intro.html">Programación de procesadores de arquitectura IA-32</a> : <a class="el" href="../../d8/d4b/ia32_assembly_basics.html">Ensamblador para procesadores IA-32</a> : Creación y uso de rutinas</p>
<p>En los lenguajes de alto nivel, además de bifurcaciones y ciclos, también se usan las rutinas como mecanismos para organizar la funcionalidad de un programa.</p>
<p>Para implementar rutinas, el procesador incluye entre otras las instrucciones <b>call</b> (invocar una rutina) y <b>ret</b> (retornar de la rutina).</p>
<p>Una rutina consta de varios componentes, entre los cuales sobresalen:</p>
<ol type="1">
<li>Nombre de la rutina: Símbolo dentro de la sección de texto que indica el inicio de la rutina.</li>
<li>Parámetros de entrada: Se utiliza la pila para pasar los parámetros a las funciones.</li>
<li>Dirección de retorno: Dirección a la cual se debe retornar una vez que se ejecuta la rutina</li>
</ol>
<p>Por ejemplo, para definir una rutina llamada nombre_rutina, el código sería el siguiente:</p>
<pre class="fragment">nombre_rutina:/* Inicio de la rutina */
   /* Instrucciones de la rutina*/
   ...
   ...
   ...
  ret /* Fin de la rutina  (retornar) */</pre><p>Es necesario notar que la definición de una etiqueta no necesariamente implica la definición de una rutina. El concepto de <b>"Rutina"</b> lo da el uso que se haga de la etiqueta. Si para saltar a una etiqueta se usa la instrucción de salto incondicional (jmp) o alguna instrucción de salto condicional (j..), esta no es una rutina. Si por el contrario, para saltar a una etiqueta se usa la instrucción call (ver explicación más adelante), y después de esa etiqueta existe una instrucción ret a la cual se llega sin importar la lógica de programación, entonces la etiqueta sí puede ser considerada una "Rutina".</p>
<h1><a class="anchor" id="calling_routines"></a>
Invocación a Rutinas</h1>
<p>La llamada a una rutina se realiza por medio de la instrucción call (en sintaxis AT&amp;T e Intel), especificando la etiqueta (el nombre de la rutina) definido en ensamblador:</p>
<pre class="fragment">call nombre_rutina
</pre><p>De esta forma, se estará invocando a la rutina nombre_rutina, sin pasarle parámetros.</p>
<p>También es posible, aunque poco común, realizar llamadas a rutinas que se encuentran en otros segmentos de memoria. En este caso se utiliza la instrucción lcall.</p>
<h2><a class="anchor" id="routine_parameters"></a>
Parámetros de entrada de las rutinas</h2>
<p>Si se desean pasar parámetros a una rutina, éstos se deben almacenar en la pila mediante la instrucción push, en el orden inverso en el que se van a utilizar en la rutina antes de ejecutar la instrucción call.</p>
<p>Por ejemplo, para invocar a una rutina y pasarle n parámetros (parámetro 1, parámetro 2, .. , parámetro n), primero se deben insertar los parámetros en orden inverso en la pila (del último al primero) antes de la instrucción call:</p>
<pre class="fragment">push parametro n
push parametro n-1
...
push parametro 2
push parametro 1
</pre><p>La cantidad de bytes que ocupa cada parámetro en la pila depende del modo de operación del procesador. En modo real, cada parámetro ocupa dos bytes (16 bits). En modo protegido, cuatro bytes (32 bits) y en modo de 64 bits cada parámetro ocupa ocho bytes.</p>
<p>Luego se utiliza la instrucción call, especificando el símbolo (la etiqueta) de la rutina que se desea ejecutar:</p>
<pre class="fragment">call nombre_rutina
</pre><p>La instrucción call almacena automáticamente en la pila dirección de memoria de la próxima instrucción a ejecutar luego del call (la dirección de retorno), y establece el registro EIP (instruction pointer) al desplazamiento en el segmento de código en la cual se encuentra definido el símbolo con el nombre de la rutina.</p>
<p>De esta forma, en el momento de llamar a una rutina, la pila se encuentra así:</p>
<pre class="fragment">      +--------------------+    
      |  valor             |                                       
      +--------------------+ &lt;- ESP antes de insertar los parámetros y de
      | Parámetro N        |    invocar la rutina (call)
      +--------------------+     
      | Parámetro N-1      |     
      +--------------------+
      | .....              |  
      +--------------------+
      | Parámetro 2        |  
      +--------------------+
      | Parámetro 1        |  
      +--------------------+
      | EIP                | -&gt; Dirección de la siguiente instrucción a ejecutar
      | (Dir. de retorno)  |    al retornar de la rutina (dirección de retorno)
      +--------------------+ &lt;-- ESP después de call                           
      |                    |                              
      |  Espacio           |
      |  disponible en     |
      |  la pila           |
      |                    |
      |                    |
      +--------------------+ &lt;---  Base de la pila. SS apunta a la Base de la Pila
      |                    |
      |                    |
      +--------------------+</pre><h2><a class="anchor" id="rotine_return"></a>
Retorno de una rutina</h2>
<p>Cuando dentro de una rutina se busque retornar la ejecución al punto en el cual fue invocada, se debe usar la instrucción <b>ret</b>. Esta instrucción saca del tope de la pila la dirección de retorno, y establece el registro EIP con este valor. Se debe garantizar que el tope de la pila contiene una dirección de retorno válida, o de lo contrario el procesador continuará su ejecución en otro punto e incluso puede llegar a causar una excepción.</p>
<p>si se insertan valores en la pila dentro de la rutina, se deben extraer antes de ejecutar la instrucción ret.</p>
<dl class="section user"><dt>Valor de retorno de las rutinas</dt><dd>Es importante tener en cuenta que la instrucción ret difiere un poco de la instrucción return de lenguajes de alto nivel, en la cual se puede retornar un valor. En ensamblador, el valor de retorno por convención se almacena siempre en el registro AL, AX, EAX o RAX de acuerdo con el modo de operación del procesador. Así, una de las últimas instrucciones dentro de la rutina antes de ret deberá almacenar el valor de retorno en el registro EAX.</dd></dl>
<p>El siguiente diagrama ilustra el funcionamiento de la instrucción ret.</p>
<p>Antes de ejecutar la instrucción ret:</p>
<pre class="fragment">          EAX
      +--------------------+    
      |  valor de retorno  |                                       
      +--------------------+
      

      +--------------------+    
      |  valor             |                                       
      +--------------------+ 
      | Parámetro N        |   
      +--------------------+     
      | Parámetro N-1      |     
      +--------------------+
      | .....              |  
      +--------------------+
      | Parámetro 2        |  
      +--------------------+
      | Parámetro 1        |  
      +--------------------+
      | EIP                | 
      | (Dir. de retorno)  |   
      +--------------------+ &lt;-- ESP                         
      |                    |                              
      |  Espacio           |    
      |  disponible en     |
      |  la pila           |
      |                    |
      |                    |
      +--------------------+ &lt;---  Base de la pila. SS apunta a la Base de la Pila
      |                    |
      |                    |
      +--------------------+
</pre><p>Después de ejecutar la instrucción ret</p>
<pre class="fragment">          EAX
      +--------------------+    
      |  valor de retorno  |                                       
      +--------------------+
      

      +--------------------+    
      |  valor             |                                       
      +--------------------+ 
      | Parámetro N        |   
      +--------------------+     
      | Parámetro N-1      |     
      +--------------------+
      | .....              |  
      +--------------------+
      | Parámetro 2        |  
      +--------------------+
      | Parámetro 1        |  
      +--------------------+ &lt;-- ESP
      | EIP                | 
      | (Dir. de retorno)  |  --&gt; EIP La ejecución continúa en esta dirección  
      +--------------------+                          
      |                    |                              
      |  Espacio           |    
      |  disponible en     |
      |  la pila           |
      |                    |
      |                    |
      +--------------------+ &lt;---  Base de la pila. SS apunta a la Base de la Pila
      |                    |
      |                    |
      +--------------------+</pre><p>Dado que al retornar de la rutina los parámetros aún se encuentran en la pila, es necesario avanzar ESP para que apunte a la posición de memoria en la cual se encontraba antes de insertar los parámetros. Para lograr este propósito se adiciona un número de bytes a ESP: </p>
<pre class="fragment">add esp, N
</pre><p> Donde N corresponde al número de bytes que se almacenaron en la pila como parámetros:</p>
<ul>
<li>En modo real cada parámetro ocupa dos bytes en la pila, por lo cual se deberá sumar 2 * el número de parámetros a SP.</li>
<li>En modo protegido cada parámetro ocupa cuatro bytes en la pila, por lo que se deberá sumar 4 * el número de parámetros a ESP.</li>
<li>En modo de 64 bits se deberá sumar 8 * el número de parámetros a RSP.</li>
</ul>
<p>De forma general, el formato para invocar una rutina que recibe <b>N</b> parámetros es el siguiente:</p>
<pre class="fragment">push parametroN
push parametroN-1
...
push parametro2
push parametro1
call nombre_rutina
add esp, N
</pre><h1><a class="anchor" id="routine_example"></a>
Ejemplo de implementación de Rutinas en Ensamblador</h1>
<p>A continuación se muestra la implementación general de una rutina en lenguaje ensamblador. Dentro de la rutina se crea un "marco de pila", necesario para manejar correctamente las variables que fueron pasadas como parámetro en la pila y las variables locales.</p>
<p>El concepto de "marco de pila" se explicará tomando como base la plantilla de rutina en modo real. En este modo se usan los registros SP, BP e IP.</p>
<p>En los demás modos de operación del procesador el marco de pila funciona en forma similar, pero se deben expandir los registros a sus equivalentes en 32 y 64 bits, y se deberá sumar el número de bytes de acuerdo con el tamaño de los registros.</p>
<p>En sintaxis AT&amp;T:</p>
<pre class="fragment">nombre_rutina:
   pushw %bp   /*Almacenar %bp en la pila*/
   movw %sp, %bp  /*Establecer %bp con el valor de %sp*/
    /*Ya se ha creado un marco de pila*/
   ...
   (instrucciones de la rutina)
   ...

    /*Cerrar el marco de pila:*/
   movw %bp, %sp  /*Mover %bp a %sp*/
   popw %bp/*Recuperar el valor original de %bp */

   ret /* Retornar de la rutina */</pre><p>En sintaxis Intel:</p>
<pre class="fragment">nombre_rutina:
   push bp   /*Almacenar bp en la pila*/
   mov bp, sp  /*Establecer bp con el valor de sp*/
    /*Ya se ha creado un marco de pila*/
   ...
   (instrucciones de la rutina)
   ...

    /*Cerrar el marco de pila:*/
   mov sp, bp  /*Mover bp a sp*/
   pop bp/*Recuperar el valor original de %bp */

   ret  /* Retornar de la rutina*/</pre><dl class="section user"><dt>Explicación de la plantilla de rutina</dt><dd></dd></dl>
<p>En esta explicación se supone que el código ha insertado los parámetros en la pila e invocó la instrucción call para ejecutar la rutina.</p>
<p>Con la instrucción</p>
<pre class="fragment">   pushw %bp   /* Sintaxis AT&amp;T */
</pre><p> ó </p>
<pre class="fragment"> push bp    /* Sintaxis Intel */
</pre><p>La pila queda dispuesta de la siguiente forma:</p>
<pre class="fragment">      +--------------------+    
      |  valor             |                                       
      +--------------------+ 
      | Parámetro N        |   
      +--------------------+     
      | Parámetro N-1      |     
      +--------------------+
      | .....              |  
      +--------------------+
      | Parámetro 2        |  
      +--------------------+
      | Parámetro 1        |  
      +--------------------+
      |  IP                | 
      | (Dir. de retorno)  |   
      +--------------------+
      | Valor de  BP       | Se almacena el valor de BP en la pila
      +--------------------+ &lt;-- SP                        
      |                    |                              
      |  Espacio           |    
      |  disponible en     |
      |  la pila           |
      |                    |
      |                    |
      +--------------------+ &lt;---  SS apunta a la base de la pila 
      |                    |
      |                    |
      +--------------------+
</pre><p>Observe que SP apunta ahora a la posición de memoria en la pila en la cual se almacenó el valor que tenía BP originalmente. Esto permite modificar BP, y recuperar su valor original luego de terminadas las instrucciones de la rutina y antes de retornar al punto desde el cual se invocó la rutina.</p>
<p>La instrucción </p>
<pre class="fragment">movw %sp, %bp  /* Sintaxis AT&amp;T */
</pre><p> ó </p>
<pre class="fragment"> mov bp, sp /* Sintaxis Intel */
</pre><p>Establece a EBP con el mismo valor de SP, con lo cual BP apunta a la misma dirección de memoria a la cual apunta SP:</p>
<pre class="fragment">      +--------------------+    
      |  valor             |                                       
      +--------------------+ 
      | Parámetro N        |   
      +--------------------+     
      | Parámetro N-1      |     
      +--------------------+
      | .....              |  
      +--------------------+
      | Parámetro 2        |  
      +--------------------+
      | Parámetro 1        |  
      +--------------------+
      |  IP                | 
      | (Dir. de retorno)  |   
      +--------------------+
      | Valor de  BP       | Se almacena el valor de BP en la pila
      +--------------------+ &lt;-- SP  &lt;-- BP                       
      |                    |                              
      |  Espacio           |    
      |  disponible en     |
      |  la pila           |
      |                    |
      |                    |
      +--------------------+ &lt;---  SS apunta a la base de la pila 
      |                    |
      |                    |
      +--------------------+
</pre><p>Con esta instrucción se termina el proceso de crear el marco de pila. Ahora es totalmente seguro decrementar el valor de SP con el propósito de crear espacios para las variables locales a la rutina, o de insertar otros valores en la pila.</p>
<p>Por ejemplo, la instrucción </p>
<pre class="fragment">subw $4, %sp /* Sintaxis AT&amp;T */  
</pre><p> ó </p>
<pre class="fragment">sub sp, 4  /* Sintaxis Intel */
</pre><p>Crea un espacio de 4 bytes (2 words) en la pila, que ahora se encontrará así:</p>
<pre class="fragment">      +--------------------+    
      |  valor             |                                       
      +--------------------+ 
      | Parámetro N        |   
      +--------------------+     
      | Parámetro N-1      |     
      +--------------------+
      | .....              |  
      +--------------------+
      | Parámetro 2        |  
      +--------------------+
      | Parámetro 1        |  
      +--------------------+
      |  IP                | 
      | (Dir. de retorno)  |   
      +--------------------+
      | Valor de  BP       |                                        
      +--------------------+ &lt;-- BP            
      | Espacio disponible |  
      +--------------------+
      | Espacio disponible |  
      +--------------------+ &lt;-- SP            
      |                    |                              
      |  Espacio           |    
      |  disponible en     |
      |  la pila           |
      |                    |
      |                    |
      +--------------------+ &lt;---  SS apunta a la base de la pila 
      |                    |
      |                    |
      +--------------------+
</pre><p>Observe que ESP se decrementa, pero BP sigue apuntando al inicio del marco de pila. Por esta razón, el puntero BP se denomina Base Pointer (puntero base), ya que con respecto a él es posible acceder tanto los parámetros enviados a la rutina, como las variables locales creadas en ésta.</p>
<p>Por ejemplo, la instrucción </p>
<pre class="fragment">movw 4(%bp), %ax /* Sintaxis AT&amp;T */
</pre><p> ó </p>
<pre class="fragment">mov ax, WORD PTR [ bp + 4 ] /* Sintaxis Intel */
</pre><p>Mueve el contenido de la memoria en la posición SS:[BP + 4] al registro AX, es decir que almacena el primer parámetro pasado a la rutina en el registro AX.</p>
<p>A continuación se presenta de nuevo el estado actual de la pila, para visualizar los diferentes desplazamientos a partir del registro BP.</p>
<pre class="fragment">      +--------------------+    
      |  valor             |                                       
      +--------------------+ 
      | Parámetro N        |   
      +--------------------+ &lt;-- BP + 2*N      
      | Parámetro N-1      |     
      +--------------------+ ...
      | .....              |  
      +--------------------+ &lt;-- BP + 8
      | Parámetro 2        |  
      +--------------------+ &lt;-- BP + 6
      | Parámetro 1        |  
      +--------------------+ &lt;-- BP + 4
      |  IP                | 
      | (Dir. de retorno)  |   
      +--------------------+ &lt;-- BP + 2
      | Valor de  BP       |                                        
      +--------------------+ &lt;-- BP            
      | Espacio disponible |  
      +--------------------+ &lt;-- BP - 1
      | Espacio disponible |  
      +--------------------+ &lt;-- SP  &lt;-- BP - 4        
      |                    |                              
      |  Espacio           |    
      |  disponible en     |
      |  la pila           |
      |                    |
      |                    |
      +--------------------+ &lt;---  SS apunta a la base de la pila 
      |                    |
      |                    |
      +--------------------+
</pre><p>De esta forma, la instrucción </p>
<pre class="fragment">movw %ax, -2(%bp) /* Sintaxis AT&amp;T */
</pre><p> ó </p>
<pre class="fragment">mov WORD PTR [ bp - 2 ], ax /* Sintaxis Intel */
</pre><p>Almacena el valor del registro AX en el primer word de espacio de la pila.</p>
<p>Se puede observar que si se crea un marco de pila estándar con las instrucciones mencionadas, siempre el primer parámetro que se paso a la rutina se encontrará en (BP + 4), el segundo en (BP + 6) y así sucesivamente.</p>
<p>Se debe tener en cuenta que si dentro de la rutina se modifica el valor del registro BP, se deberá almacenar su valor con anterioridad en la pila o en otro registro.</p>
<dl class="section user"><dt>Cerrar el marco de Pila</dt><dd></dd></dl>
<p>Al finalizar la rutina se deberá cerrar el marco de pila creado. La instrucción </p>
<pre class="fragment"> movw %bp, %sp /* Sintaxis AT&amp;T */
</pre><p> ó </p>
<pre class="fragment">mov sp, bp  /* Sintaxis Intel */
</pre><p>Cierra el espacio creado para las variables locales, al apuntar SP a la misma dirección de memoria en la pila a la que BP. Luego de esta instrucción la pila lucirá así:</p>
<pre class="fragment">      +--------------------+    
      |  valor             |                                       
      +--------------------+ 
      | Parámetro N        |   
      +--------------------+     
      | Parámetro N-1      |     
      +--------------------+
      | .....              |  
      +--------------------+
      | Parámetro 2        |  
      +--------------------+
      | Parámetro 1        |  
      +--------------------+
      |  IP                | 
      | (Dir. de retorno)  |   
      +--------------------+
      | Valor de  BP       |                                        
      +--------------------+ &lt;-- BP  &lt;-- SP  
      |                    |  
      +--------------------+
      |                    |  
      +--------------------+ &lt;-- SP antes de cerrar el marco de pila
      |                    |                              
      |  Espacio           |    
      |  disponible en     |
      |  la pila           |
      |                    |
      |                    |
      +--------------------+ &lt;---  SS apunta a la base de la pila 
      |                    |
      |                    |
      +--------------------+
</pre><p>En este momento ya no es seguro acceder a los valores almacenados en el espacio para variables locales.</p>
<p>Ahora se deberá recuperar el valor original de BP antes de crear el marco de pila: </p>
<pre class="fragment">popw %bp /* Sintaxis AT&amp;T */
</pre><p> ó </p>
<pre class="fragment">pop bp /* Sintaxis Intel */
</pre><p>Con ello la pila se encontrará en el siguiente estado:</p>
<pre class="fragment">      +--------------------+    
      |  valor             |                                       
      +--------------------+ 
      | Parámetro N        |   
      +--------------------+     
      | Parámetro N-1      |     
      +--------------------+
      | .....              |  
      +--------------------+
      | Parámetro 2        |  
      +--------------------+
      | Parámetro 1        |  
      +--------------------+
      |  IP                | 
      | (Dir. de retorno)  |   
      +--------------------+ &lt;-- SP
      | Valor de  BP       | --&gt; Este valor sale de la pila y se almacena en BP
      +--------------------+     
      |                    |                              
      |  Espacio           |    
      |  disponible en     |
      |  la pila           |
      |                    |
      |                    |
      +--------------------+ &lt;---  SS apunta a la base de la pila 
      |                    |
      |                    |
      +--------------------+
</pre><p>Ahora SP apunta a la dirección de retorno de la rutina (donde debe continuar la ejecución). La instrucción </p>
<pre class="fragment">ret
</pre><p>Toma de la pila la dirección de retorno (la dirección de memoria de la instrucción siguiente a la cual se llamó la rutina mediante call), y realiza un jmp a esa dirección.</p>
<p>Note que luego de retornar de la rutina, la pila se encontrará en el siguiente estado:</p>
<pre class="fragment">      +--------------------+    
      |  valor             |                                       
      +--------------------+ 
      | Parámetro N        |   
      +--------------------+     
      | Parámetro N-1      |     
      +--------------------+
      | .....              |  
      +--------------------+
      | Parámetro 2        |  
      +--------------------+
      | Parámetro 1        |  
      +--------------------+ &lt;-- SP  (los parámetros continúan en la pila)
      | IP                 | --&gt; Este valor sale de la pila y se almacena en IP
      +--------------------+                             
      |  Espacio           |    
      |  disponible en     |
      |  la pila           |
      |                    |
      |                    |
      +--------------------+ &lt;---  SS apunta a la base de la pila 
      |                    |
      |                    |
      +--------------------+
</pre><p>Por esta razón es necesario avanzar SS en un valor igual al número de bytes que se enviaron como parámetro a la rutina. Si se enviaron N parámetros a la pila, el numero de bytes que se deberán sumar a sp son 2 * N (En modo real cada parámetro ocupa un word = 2 bytes). </p>
<pre class="fragment">addw $M, %sp /* Sintaxis AT&amp;T */
</pre><p> ó </p>
<pre class="fragment">add sp, M /* Sintaxis Intel */
</pre><p>Donde M representa el número de bytes a desplazar SP.</p>
<p>Con estas instrucciones la pila se encontrará en el mismo estado que antes de invocar la rutina:</p>
<pre class="fragment">      +--------------------+    
      |  valor             |                                       
      +--------------------+ &lt;- ESP (tope de la pila)
      |                    |
      |                    |
      |                    |
      |                    |
      |                    |    
      |                    |     
      |                    |                              
      |  Espacio           |
      |  disponible en     |
      |  la pila           |
      |                    |
      |                    |
      +--------------------+ &lt;---  SS apunta a la Base de la Pila
      |                    |
      |                    |
      +--------------------+</pre><h1><a class="anchor" id="pm_routine_template"></a>
Plantilla de Rutina en Modo Protegido de 32 bits</h1>
<p>La plantilla de una rutina en modo protegido de 32 bits es muy similar a la de modo real. La principal diferencia entre las dos consiste en el tamaño de los registros, que se expanden de 16 a 32 bits (BP se expande a EBP y SP se expande a ESP).</p>
<p>También es importante recordar que cada parámetro almacenado en la pila ocupa 4 bytes (32 bits), por lo cual el valor que se debe sumar a ESP después de retornar de la rutina es 4 * el número de parámetros insertados.</p>
<dl class="section user"><dt>En sintaxis AT&amp;T</dt><dd></dd></dl>
<pre class="fragment">nombre_rutina:
   pushl %ebp   /*Almacenar %ebp en la pila*/
   movw %esp, %ebp  /*Establecer %ebp con el valor de %esp*/
    /*Ya se ha creado un marco de pila*/
   ...
   (instrucciones de la rutina)
   Por ejemplo, para obtener el primer parámetro de la pila sería:
   mov 8(%ebp), %eax
   ...

    /*Cerrar el marco de pila:*/
   movw %ebp, %esp  /*Mover %ebp a %esp*/
   popw %ebp/*Recuperar el valor original de %ebp */

   ret /* Retornar de la rutina */</pre><dl class="section user"><dt>En sintaxis Intel</dt><dd></dd></dl>
<pre class="fragment">nombre_rutina:
   push ebp   /*Almacenar ebp en la pila*/
   mov ebp, esp  /*Establecer ebp con el valor de esp*/
    /*Ya se ha creado un marco de pila*/
   ...
   (instrucciones de la rutina)
   Por ejemplo, para obtener el primer parámetro de la pila sería:
   mov eax, [ebp + 8]
   ...

    /*Cerrar el marco de pila:*/
   mov esp, ebp  /*Mover ebp a esp*/
   pop ebp/*Recuperar el valor original de ebp */

   ret  /* Retornar de la rutina*/</pre><dl class="section see"><dt>Ver también</dt><dd><a class="el" href="../../da/de6/ia32_using_the_stack.html">Uso de la Pila en IA-32</a> </dd>
<dd>
<a class="el" href="../../d8/d4b/ia32_assembly_basics.html">Ensamblador para procesadores IA-32</a> </dd>
<dd>
<a class="el" href="../../d0/d4f/ia32_execution_environment.html">Entorno de ejecución en IA-32</a> </dd>
<dd>
<a class="el" href="../../d3/d4c/ia32_operation_modes.html">Modos de Operación de procesadores IA-32</a> </dd>
<dd>
<a class="el" href="../../d4/de9/ia32_memory_organization.html">Organización de Memoria en Procesadores IA-32</a> </dd>
<dd>
<a class="el" href="../../d0/d4f/ia32_execution_environment.html">Entorno de ejecución en IA-32</a> </dd>
<dd>
<a class="el" href="../../d0/dec/protected_mode_setup.html">Paso a Modo Protegido en Procesadores IA-32</a> </dd>
<dd>
<a class="el" href="../../d8/dfe/gdt_page.html">Tabla Global de Descriptores - GDT</a> </dd>
<dd>
<a href="http://www.gnu.org/software/grub/">http://www.gnu.org/software/grub/</a> Página oficial de GRUB (Enlace externo) </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generado por &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
