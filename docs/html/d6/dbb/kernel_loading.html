<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Proyecto 10 - Gestión de Memoria Física: Carga y Ejecución del Kernel compatible con Multiboot</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Proyecto 10 - Gestión de Memoria Física
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">Aprendiendo Sistemas Operativos</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Buscar');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Página&#160;principal</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Páginas&#160;relacionadas</span></a></li>
      <li><a href="../../modules.html"><span>Módulos</span></a></li>
      <li><a href="../../annotated.html"><span>Estructuras&#160;de&#160;Datos</span></a></li>
      <li><a href="../../files.html"><span>Archivos</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Buscar" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Todo</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Estructuras de Datos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Archivos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Funciones</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>&apos;typedefs&apos;</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>&apos;defines&apos;</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Grupos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Páginas</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Carga y Ejecución del Kernel compatible con Multiboot </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Autor</dt><dd>Erwin Meza Vega <a href="#" onclick="location.href='mai'+'lto:'+'eme'+'za'+'v@g'+'ma'+'il.'+'co'+'m'; return false;">emeza<span style="display: none;">.nosp@m.</span>v@gm<span style="display: none;">.nosp@m.</span>ail.c<span style="display: none;">.nosp@m.</span>om</a></dd></dl>
<p><a class="el" href="../../index.html#project_start">Información del Proyecto</a> : Carga y Ejecución del Kernel</p>
<p>El kernel creado en este proyecto es compatible con la Especificación Multiboot. Todos los archivos que lo componen se compilan en un único archivo en formato ELF (el formato ejecutable de Linux) y se almacena en una imagen de disco duro. Esta imagen de disco ya tiene integrado a GRUB.</p>
<p>GRUB es un cargador de arranque que cumple con la Especificación Multiboot. De esta forma, si se desarrolla un kernel compatible con Multiboot, podrá ser cargado por GRUB sin ningún inconveniente.</p>
<p>El archivo ejecutable del kernel se organiza para que sea cargado por GRUB a la dirección de memoria 0x100000, y para que su ejecución comience en la etiqueta <b>start</b> del archivo <a class="el" href="../../d4/dfb/start_8_s.html" title="Punto de entrada del kernel.">src/start.S</a>.</p>
<dl class="section user"><dt>Imagen de disco del proyecto</dt><dd></dd></dl>
<p>La imagen de disco ya contiene al cargador de arranque GRUB en su sector de arranque maestro, y tiene una sola partición. Dentro de esta partición se encuentran los archivos necesarios para iniciar GRUB, y el código del kernel compilado.</p>
<p>La partición se encuentra formateada con el sistema de archivos ext2 (linux), y su contenido se muestra en el siguiente esquema:</p>
<pre class="fragment">/ -+    &lt;-- Directorio raíz de la única partición en la imagen de disco
   |
   boot &lt;-- Almacena los archivos de GRUB y el kernel compilado
       |  
       |  
       grub  &lt;-- Almacena los archivos de GRUB
       |   |
       |   |
       | e2fs_stage_1_5  &lt;-- Etapa 1.5 de GRUB. cargado por la etapa 1 de GRUB
       |   |                 Contiene el código para manejar el sistema de 
       |   |                 archivos de la partición (ext2). Este archivo
       |   |                 es opcional, ya que al instalar GRUB este archivo
       |   |                 se copió en el sector adyacente al sector de
       |   |                 arranque.
       |   |
       | menu.lst    &lt;-- Archivo de configuración leido por GRUB al arranque.
       |   |             especifica la configuración del menú que despliega
       |   |             GRUB al arranque y ubicación del kernel en 
       |   |             (la imagen de) disco.
       | stage1      &lt;-- Etapa 1 de GRUB. Este archivo es opcional, ya que se
       |   |             copió en el sector de arranque del disco al instalar 
       |   |             GRUB.
       |   |             Carga la etapa 1.5 de GRUB. Después carga la
       |   |             etapa 2 de GRUB desde el disco y le pasa el control.
       |   |             Este archivo es opcional.
       |   |
       | stage2      &lt;-- Etapa 2 de GRUB. Cargada por la etapa 1 de GRUB.
       |                 Configura el sistema y presenta el menú que
       |                 permite cargar el kernel.
       |                 Este archivo es obligatorio.
       |                 Cuando el usuario selecciona la única opción 
       |                 disponible: cargar y pasar el control el archivo kernel
       |                 que se encuentra en el directorio /boot de la imagen
       |                 de disco
       |                 El kernel se carga a la dirección de memoria 0x100000
       |                 (1 MB)
       |                  
       kernel   &lt;-- Archivo que contiene el código compilado del kernel.
</pre><h1><a class="anchor" id="grub_kernel_loading"></a>
Papel de GRUB en la carga del Kernel</h1>
<p>Al iniciar el sistema, la BIOS carga el código de GRUB almacenado en el sector de arranque de la imagen de disco. Cuando GRUB se instala en la imagen de disco, el contenido del archivo stage_1 se incluye dentro del sector de arranque.</p>
<p>El código del archivo stage1 cargado en memoria recibe el control. Este código a su vez carga en memoria la etapa 1.5 de GRUB, que ha sido copiada en la imagen del disco a continuación del sector de arranque (por esta razón el archivo e2fs_stage_1_5 también es opcional). La etapa 1.5 de GRUB contiene el código para acceder a particiones de disco con formato ext2.</p>
<p>El código de la etapa 1 y la etapa 1.5 de GRUB cargan la etapa 2 de GRUB (el archivo stage_2, que es obligatorio), y luego le pasan el control.</p>
<p>El código de la etapa 2 lee el archivo menu.lst, que contiene las opciones de la interfaz del menú que se presenta al usuario y las diferentes opciones de sistemas operativos a cargar. El contenido de este archivo se reproduce a continuación:</p>
<pre class="fragment">default 0
timeout 10
color cyan/blue white/blue

title Aprendiendo Sistemas Operativos
root (hd0,0)
kernel /boot/kernel</pre><p>Básicamente se establece un menú en el cual la primera (y única) opción de arranque se define como opción por defecto. El parámetro <b>timeout</b> permite establecer el tiempo que espera GRUB antes de cargar automáticamente la opción de arranque definida por defecto.</p>
<p>Es posible definir múltiples opciones de arranque, si en (la imagen de) el disco se tienen instalados varios sistemas operativos. (Por ejemplo, Linux y Windows).</p>
<p>La única opción de arranque configurada consta de tres elementos:</p>
<ul>
<li><b>title</b> permite especificar el texto de la opción de menú que presentará GRUB</li>
<li><b>root</b> especifica la partición en la cual se encuentra el kernel (hd0,0). Esta corresponde a el disco duro primario (hd0), primera (y única) partición (0).</li>
<li><b>kernel</b> Especifica la ruta dentro de la partición en la cual se encuentra el kernel del sistema operativo (el código compilado de este proyecto).</li>
</ul>
<p>Con esta configuración, al arranque del sistema se presenta el familiar menú de GRUB con la opción "Aprendiendo Sistemas Operativos". Al seleccionar esta opción, GRUB carga el archivo /boot/kernel de la imagen de disco a la posición de memoria 0x100000 (1MB) y le pasa el control de la ejecución.</p>
<p>Muchas distribuciones actuales de Linux usan a GRUB como cargador de arranque, mediante un sistema similar (con algunos aspectos complejos adicionales) al que se presenta en este proyecto.</p>
<dl class="section user"><dt>Carga de Módulos del Kernel</dt><dd></dd></dl>
<p>La Especificación Multiboot además establece que es posible cargar otros archivos necesarios para la inicialización del kernel. Estos archivos pueden ser ejecutables, imágenes, archivos comprimidos, etc. Si se desea agregar un módulo para que sea cargado por GRUB al inicio del sistema, se deberá copiar el archivo dentro de la imagen de disco (Generalmente en el mismo directorio en el cual se encuentra copiado el archivo del kernel), y se deberá adicionar para cada módulo una línea en la opción correspondiente en el archivo de configuración:</p>
<pre class="fragment">default 0
timeout 10
color cyan/blue white/blue

title Aprendiendo Sistemas Operativos
root (hd0,0)
kernel /boot/kernel
module /boot/MODULO_1 param1 param2 .. paramN
module /boot/MODULO_2 param1 param3 .. paramN

title Otro Sistema Operativo
root (hd0,0)
kernel /boot/vmlinuz</pre><p>En este caso para la opción "Aprendiendo Sistemas Operativos" se adicionaron dos módulos (MODULO_1 y MODULO_2) que deben ser cargados por GRUB junto con el kernel. Los módulos no necesariamente deben encontrarse en el mismo directorio que el archivo del kernel, pero se considera una buena práctica que se encuentren en el mismo directorio.</p>
<dl class="section user"><dt>Carga de un Ramdisk</dt><dd></dd></dl>
<p>GRUB ofrece además la posibilidad de cargar una imagen de disco en memoria junto con el kernel. A esta imagen de disco se le denomina Initial Ramdisk o initrd.</p>
<p>Esta posibilidad es aprovechada por Linux, que usa el initrd para cargar una imagen de disco comprimida que contiene código adicional para la inicialización del sistema. Al ser una imagen de disco en memoria, el kernel no necesita aún conocer la estructura ni el formato del disco duro en el cual se encuentra el resto de su código. Solo requiere conocer la posición de memoria en la cual se cargó la imagen de disco.</p>
<p>Una vez que el código y los datos del Ramdisk han sido usados, el kernel puede descartarlo y liberar el espacio de memoria en el que se cargó.</p>
<p>Consulte la opción initrd de GRUB para más detalles.</p>
<dl class="section user"><dt>Carga del kernel por GRUB</dt><dd></dd></dl>
<p>El código del kernel es cargado por GRUB a la dirección de memoria 0x100000 (1 MB), ya que dentro del encabezado multiboot del kernel se especificó esta como la dirección en la que se deseaba cargar el kernel (ver campo kernel_start dentro del Encabezado Multiboot, la etiqueta multiboot_header en el archivo <a class="el" href="../../d4/dfb/start_8_s.html" title="Punto de entrada del kernel.">start.S</a>).</p>
<p>Debido a que GRUB es un cargador de arranque compatible con la especificación Multiboot, al pasar el control al kernel se tiene el siguiente entorno de ejecución (extractado de la Especificación Multiboot, sección 3.2 Machine state):</p>
<ul>
<li>La línea de direcciones A20 se encuentra habilitada, por lo cual se tiene acceso a los 32 bits de los registros del procesador y a un espacio lineal de memoria de hasta 4 GB.</li>
<li>Existe una Tabla Global de Descriptores (GDT) temporal configurada por GRUB. En la documentación se insiste en que el kernel deberá crear y cargar su propia GDT tan pronto como sea posible.</li>
<li>GRUB ha obtenido información del sistema, y ha configurado en la memoria una estructura de datos que recopila esta información. Incluye la cantidad de memoria disponible, los módulos del kernel cargados (ninguno en este proyecto), entre otros.</li>
<li>El registro EAX contiene el valor 0x2BADB002, que indica al código del kernel que se usó un cargador compatible con la especificación Multiboot para iniciarlo.</li>
<li>El registro EBX contiene la dirección física (un apuntador de 32 bits) en la cual se encuentra la estructura de datos con la información recopilada por GRUB que puede ser usada por el kernel para conocer información del sistema (memoria disponible, módulos cargados, discos y dispositivos floppy, modos gráficos, etc).</li>
<li>En el registro de control CR0 el bit PG (paginación) se encuentra en 0, por lo cual la paginación se encuentra deshabilitada. El bit PE (Protection Enable) se encuentra en 1, por lo cual el procesador se encuentra operando en modo protegido de 32 bits.</li>
<li>El registro de segmento de código (CS) contiene un selector que referencia un descriptor de segmento válido dentro de la GDT temporal configurada por GRUB. El segmento descrito se ha configurado como segmento de <b>código</b> en modo plano (flat), es decir que tiene base 0 y límite 4 GB.</li>
<li>Los registros de segmento de datos y pila (DS, ES, FS, GS y SS) contienen un selector que referencia un descriptor de segmento válido dentro de la GDT temporal configurada por GRUB. El segmento descrito se ha configurado como un segmento de <b>datos</b> en modo plano (flat), es decir que tiene base 0 y límite 4 GB.</li>
<li>El registro apuntador al tope de la pila (ESP) debe ser configurado por el kernel tan pronto como sea posible.</li>
<li>El kernel debe deshabilitar las interrupciones, hasta que configure y cargue una tabla de descriptores de interrupción (IDT) válida. Dado a que el procesador ya se encuentra en modo protegido, no se puede usar la IDT que la BIOS configura al inicio del sistema.</li>
</ul>
<dl class="section user"><dt>Estructura de la Información Multiboot recopilada por GRUB</dt><dd></dd></dl>
<p>La estructura de datos que GRUB construye y cuyo apuntador se almacena en el registro EAX es definida por la Especificación Multiboot con el formato que se presenta a continuación. El desplazamiento se encuentra definido en bytes, es decir que cada campo ocupa 4 bytes (32 bits).</p>
<pre class="fragment">         +-------------------+
       0 | flags             | (required)| Permite identificar cuales de los  
         |                   | siguientes campos se encuentran definidos:
         +-------------------+
       4 | mem_lower         | (presente si flags[0] = 1)
       8 | mem_upper         | (presente si flags[0] = 1)
         +-------------------+
      12 | boot_device       | (presente si flags[1] = 1)
         +-------------------+
      16 | cmdline           | (presente si flags[2] = 1)
         +-------------------+
      20 | mods_count        | (presente si flags[3] = 1)
      24 | mods_addr         | (presente si flags[3] = 1)
         +-------------------+
 28 - 40 | syms              | (presente si flags[4] or
         |                   | flags[5] = 1)
         +-------------------+
      44 | mmap_length       | (presente si flags[6] = 1)
      48 | mmap_addr         | (presente si flags[6] = 1)
         +-------------------+
      52 | drives_length     | (presente si flags[7] = 1)
      56 | drives_addr       | (presente si flags[7] = 1)
         +-------------------+
      60 | config_table      | (presente si flags[8] = 1)
         +-------------------+
      64 | boot_loader_name  | (presente si flags[9] = 1)
         +-------------------+
      68 | apm_table         | (presente si flags[10] = 1)
         +-------------------+
      72 | vbe_control_info  | (presente si flags[11] = 1)
      76 | vbe_mode_info     |
      80 | vbe_mode          |
      82 | vbe_interface_seg |
      84 | vbe_interface_off |
      86 | vbe_interface_len |
         +-------------------+
</pre><p>Consulte la Especificación Multiboot para obtener más detalles acerca de esta estructura.</p>
<dl class="section user"><dt>Ejecución del Kernel</dt><dd></dd></dl>
<p>La ejecución del kernel se divide en dos partes: ejecución del código inicial (programado en lenguaje ensamblador) y ejecución del código en C.</p>
<dl class="section user"><dt>Ejecución del código inicial del Kernel</dt><dd></dd></dl>
<p>El código del kernel se encuentra organizado de forma que primero se ejecuta el código del archivo <a class="el" href="../../d4/dfb/start_8_s.html" title="Punto de entrada del kernel.">start.S</a>. Esta organización del archivo ejecutable se define en el archivo link.ld.</p>
<p>El código de <a class="el" href="../../d4/dfb/start_8_s.html" title="Punto de entrada del kernel.">start.S</a> define el encabezado multiboot, necesario para que el kernel sea reconocido por GRUB como compatible con la especificación multiboot. Este encabezado es leído e interpretado por GRUB al momento de cargar el kernel, de acuerdo con lo establecido en la especificación.</p>
<p>La ejecución inicia en la etiqueta start, en la cual se realiza un salto a la etiqueta entry_point. Se debe realizar este salto porque de no hacerlo el procesador asumiría que el encabezado multiboot (una estructura de datos insertada dentro del código) contiene instrucciones válidas y trataría de ejecutarlas.</p>
<p>El código que se encuentra luego de la etiqueta entry_point implementa las recomendaciones de la Especificación Multiboot:</p>
<ul>
<li>Deshabilitar las interrupciones</li>
<li>Configurar la pila del kernel: En este caso el tope de la pila se establece en la dirección física 0x9FC00.</li>
<li>Restablecer el registro EFLAGS</li>
</ul>
<p>Luego, el código en ensamblador almacena en la pila (recién configurada) los parámetros que enviará a la función cmain (<a class="el" href="../../d9/d26/kernel_8c.html" title="Código de inicialización del kernel en C. Este código recibe el control de start.S y continúa con la ...">kernel.c</a>). Estos parámetros son:</p>
<ul>
<li>Valor de EBX: Apuntador a la dirección de memoria en la cual GRUB ha creado la estructura de información Multiboot.</li>
<li>Valor de EAX: Número mágico, que permite al código en C verificar si el kernel fué cargado por un cargador de arranque compatible con la Especificación Multiboot.</li>
</ul>
<p>Después de insertar los parámetros en la pila, el código en ensamblador invoca la función cmain, definida en el archivo <a class="el" href="../../d9/d26/kernel_8c.html" title="Código de inicialización del kernel en C. Este código recibe el control de start.S y continúa con la ...">kernel.c</a>. Esto se logra mediante el siguiente código definido en <a class="el" href="../../d4/dfb/start_8_s.html" title="Punto de entrada del kernel.">start.S</a>:</p>
<pre class="fragment">  /* Enviar los parámetros al kernel */
  push ebx /* dirección fisica de memoria en la cual se encuentra
        la estructura de informacion multiboot. Esta puede
        ser utilizada por el kernel para obtener la informacion
        suministrada por el cargador. */
  push %eax /* Número mágico del cargador de arranque = 0x2BADB002.
        En el kernel se puede validar si se recibió este valor. En caso
        afirmativo, el kernel fué cargado por un cargador que cumple
        con la especificacion multiboot. */

  call cmain /* Pasar el control a la rutina 'cmain' en elarchivo kernel.c */
</pre><dl class="section user"><dt>Ejecución del código en C del Kernel </dt><dd></dd></dl>
<p>Se debe recordar que una función en C recibe los parámetros de forma inversa a como se insertaron en la pila en lenguaje ensamblador. Por este motivo la definición de la función cmain es la siguiente:</p>
<pre class="fragment">void cmain(unsigned int magic, void * multiboot_info)
</pre><p>Dentro de la función cmain se continúa con la inicialización del kernel. En esta función se debe incluir la llamada a otras rutinas que permitirán tener un kernel, y (en un futuro) un sistema operativo funcional.</p>
<p>Cuando la función <a class="el" href="../../d9/d26/kernel_8c.html#ac81b272b403fb3e4a4c5c1cc389b4195" title="Función principal del kernel. Esta rutina recibe el control del codigo en ensamblador de start...">cmain()</a> termina, el control se cede de nuevo al código del archivo <a class="el" href="../../d4/dfb/start_8_s.html" title="Punto de entrada del kernel.">start.S</a>. Este código retira los parámetros almacenados en la pila, y entra en un ciclo infinito para mantener ocupado el procesador y evitar que éste se reinicie:</p>
<pre class="fragment">  /* La función cmain() retorna a este punto. Se debe entrar en un ciclo
  infinito, para que el procesador no siga ejecutando instrucciones al finalizar
  la ejecución del kernel. */

loop: hlt
 jmp loop /* Ciclo infinito */
</pre><dl class="section see"><dt>Ver también</dt><dd><a href="http://www.gnu.org/software/grub/manual/multiboot/multiboot.html">http://www.gnu.org/software/grub/manual/multiboot/multiboot.html</a> Especificación Multiboot </dd>
<dd>
<a href="http://www.skyfree.org/linux/references/ELF_Format.pdf">http://www.skyfree.org/linux/references/ELF_Format.pdf</a> Especificación ELF </dd>
<dd>
<a href="http://www.gnu.org/software/grub/">http://www.gnu.org/software/grub/</a> Página oficial de GRUB (Enlace externo) </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generado por &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
