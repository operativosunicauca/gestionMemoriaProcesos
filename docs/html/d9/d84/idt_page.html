<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Proyecto 10 - Gestión de Memoria Física: IDT y Gestión de Interrupciones</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Proyecto 10 - Gestión de Memoria Física
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">Aprendiendo Sistemas Operativos</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Buscar');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Página&#160;principal</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Páginas&#160;relacionadas</span></a></li>
      <li><a href="../../modules.html"><span>Módulos</span></a></li>
      <li><a href="../../annotated.html"><span>Estructuras&#160;de&#160;Datos</span></a></li>
      <li><a href="../../files.html"><span>Archivos</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Buscar" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Todo</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Estructuras de Datos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Archivos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Funciones</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>&apos;typedefs&apos;</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>&apos;defines&apos;</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Grupos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Páginas</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">IDT y Gestión de Interrupciones </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Autor</dt><dd>Erwin Meza Vega <a href="#" onclick="location.href='mai'+'lto:'+'eme'+'za'+'v@g'+'ma'+'il.'+'co'+'m'; return false;">emeza<span style="display: none;">.nosp@m.</span>v@gm<span style="display: none;">.nosp@m.</span>ail.c<span style="display: none;">.nosp@m.</span>om</a></dd></dl>
<p><a class="el" href="../../index.html#project_start">Información del Proyecto</a> : <a class="el" href="../../d8/d50/ia32_intro.html">Programación de procesadores de arquitectura IA-32</a> : IDT y Gestión de Interrupciones</p>
<p>Una interrupción es una señal que rompe con el flujo normal del procesador, y que debe ser atendida inmediatamente.</p>
<dl class="section user"><dt>Fuentes de Interrupción</dt><dd></dd></dl>
<p>En la arquitectura IA-32 se definen tres fuentes básicas de interrupción:</p>
<ul>
<li>Excepciones: Son condiciones de error que se presentan en la ejecución. Por ejemplo, al realizar una división por cero se lanza la excepción Division By Zero. Es una interrupción generada internamente por el procesador.</li>
<li>Interrupciones de los dispositivos de hardware (discos, teclado, floppy, etc). Los dispositivos de hardware realizan solicitudes de interrupción (Interrupt Request - IRQ). Cada IRQ tiene asociado un número de interrupción predefinido, pero es posible cambiarlo por programación.</li>
<li>Interrupciones por software, generadas mediante la instrucción <pre class="fragment">  int N
</pre> donde N es el número de interrupción.</li>
</ul>
<p>La arquitectura IA-32 soporta 256 interrupciones. De estas, las 32 primeras (número 0 a 31) se asignan por defecto a las excepciones del procesador.</p>
<p>A continuación se muestra una descripción de las interrupciones para IA-32.</p>
<pre class="fragment">Número de    | Descripción
Interrupción |
(dec/hex)    |
-------------|-------------------------------------------------
  0  0x00    | Divide error:
             | Ocurre durante una instrucción DIV, cuando el divisor
             | es cero o cuando ocurre un desbordamiento del cociente.
             | Esta excepción no genera código de error.

  1  0x01    | (Reservada)
             | Esta excepción no genera código de error.  

  2  0x02    | Nonmaskable interrupt:
             | Ocurre debido a una interrupcion de hardware que no se puede
             |  enmascarar.
             | Esta excepción no genera código de error.

  3  0x03    | Breakpoint:
             | Ocurre cuando el procesador encuentra una instrucción INT 3
             | Esta excepción no genera código de error.

  4  0x04    | Overflow:
             | Ocurre cuando el procesador encuentra una instrucción INTO
             | y el bit OF (Overflow) del registro EFLAGS se encuentra activo.
             | Esta excepción no genera código de error.

  5  0x05    | Bounds check (BOUND instruction):
             | Ocurre cuando el procesador, mientras ejecuta una instrucción
             | BOUND, encuentra que el operando excede el límite especificado.
             | Esta excepción no genera código de error.

  6  0x06    | Invalid opcode:
             | Ocurre cuando se detecta un código de operación inválido.
             | Esta excepción no genera código de error.

  7  0x07    | Device Not Available (No Math Coprocessor)
             | Ocurre para alguna de las dos condiciones:
             | - El procesador encuentra una instrucción ESC (Escape)
             |   y el bit EM (emulate) bit de CR0 (control register zero)
             |   se encuentra activo.
             | - El procesador encuentra una instrucción WAIT o una instrucción
             |   ESC y los bits MP (monitor coprocessor) y TS (task switched)
             |   del registro CR0 se encuentran activos.
             | Esta excepción no genera código de error.

  8  0x08    | Double fault:
             | Ocurre cuando el procesador detecta una excepción mientras trata
             | de invocar el manejador de una excepción anterior.
             | Esta excepción genera un código de error.

  9  0x09    | Coprocessor segment overrun:
             | Ocurre cuando se detecta una violación de página o segmento
             | mientras se transfiere la porción media de un operando de 
             | coprocesador al NPX.
             | Esta excepción no genera código de error.

 10  0xA     | Invalid TSS:
             | Ocurre si el TSS es inválido al tratar de cambiar de tarea (Task 
             |  switch).
             | Esta excepción genera código de error.

 11  0xB     | Segment not present:
             | Ocurre cuando el procesador detecta que el bit P (presente) de un
             | descriptor de segmento es cero.
             | Esta excepción genera código de error.

 12  0xC     | Stack exception:
             | Ocurre para las siguientes condiciones:
             | - Como resultado de una violación de límite en cualquier operación
             |   que se refiere al registro de segmento de pila (SS)
             | - Cuando se trata de establecer SS con un selector cuyo descriptor
             |   asociado se encuentra marcado como no presente, pero es válido
             | Esta excepción genera código de error.

 13  0xD     | General protection violation (GP):
             | Cada violación de protección que no causa otra excepción
             | causa una GP.
             | - Exceder el límite de segmento para CS, DS, ES, FS, o GS
             | - Exceder el límite de segmento cuando se referencia una tabla de
             |   descriptores
             | - Transferir el control a un segmento que no es ejecutable
             | - Escribir en un segmento de datos de sólo lectura o en un 
             |   segmento de código
             | - Leer de un segmento marcado como sólo de ejecución
             | - Cargar en SS un selector que referencia a un segmento de sólo 
             |   lectura
             | - Cargar SS, DS, ES, FS, o GS con un selector que referencia a un
             |   descriptor de tipo "sistema"
             | - Cargar DS, ES, FS, o GS con un selector que referencia a un 
             |   descriptor de segmento marcado como ejecutable que además no se
             |   puede leer
             | - Cargar en SS un selector que referencia un descriptor  de 
             |   segmento ejecutable
             | - Acceder a la memoria por medio de DS, ES, FS, o GS cuando estos
             |   registros de segmento contienen un selector nulo
             | - Pasar la ejecución (task switch) a una tarea marcada como "Busy"
             | - Violar las reglas de privilegios
             | - Cargar CR0 con los bits PG=1 y PE=0 (habilitar la paginación y
             |      no habilitar el modo protegido)
             | - Lanzar una interrupción o una excepción a través de un trap 
             |   gate desde Modo Virtual 8086 a un privilegio (DPL) diferente 
             |   de cero 
             | Esta excepción genera código de error.

 14  0xE     | Page fault:
             | Ocurre cuando la paginación está habilitada (PG = 1) en CR0
             | y el procesador detecta alguna de las siguientes condiciones
             | cuando trata de traducir una dirección lineal a física:
             | - El directorio de tabla de páginas o la tabla de páginas requerido
             |   para realizar la traducción tiene 0 en su bit de presente (P)
             | - El procedimiento actual no tiene los suficientes privilegios para
             |   acceder la página indicada.
             | Esta excepción genera código de error.

 15  0xF     | (Reservada)
             | Esta excepción no genera código de error.

 16  0x10    | x87 FPU Floating-Point Error (Math Fault)
             | Ocurre cuando el procesador detecta una señal del coprocesador en el
             | pin de entrada ERROR#.

 17  0x11    | Alignment Check
             | Ocurre cuando se realiza una referencia de datos en la memoria a 
             | una región no alineada.
             | Esta excepción genera código de error.
 
 18  0x12    | Machine Check
             | Depende del modelo y las características del procesador.
             | Esta excepción no genera código de error.
          
 19  0x23    | SIMD Floating-Point Exception
             | Ocurre cuando existe un error en las instrucciones SSE/SSE2/SSE3.
             | Esta excepción no genera código de error.
          

 20  0x24    | Reservadas por Intel.
  hasta      |
 31  0x1F    | Estas excepciones no generan código de error.
             |
             
              
 32  0x20    | Interrupción externa o interrupción invocada mediante la
  hasta      | instrucción INT N
 255 0xFF    | Estas interrupciones no generan código de error</pre> <dl class="section note"><dt>Nota</dt><dd>Tabla adaptada de Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 3A: System Programming Guide, Part 1. Sección 5.3.1.</dd></dl>
<h1><a class="anchor" id="idt_structure"></a>
Tabla de Descriptores de Interrupción (IDT)</h1>
<p>La IDT es una estructura de datos que usa el procesador en el momento en que ocurre la interrupción, y que debe estar configurada antes de habilitar las interrupciones. Es una tabla que contiene una serie de entradas denominadas "descriptores", que definen entre otros parámetros la dirección de memoria en la cual se encuentra cada rutina de manejo de interrupción.</p>
<p>El siguiente esquema muestra la IDT y las rutinas de manejo de interrupción en memoria:</p>
<pre class="fragment">        +------------------------------+
        |                              |
        |                              |
        +------------------------------+
        | Rutina de manejo de          |&lt;------+
        | interrupción 255             |       |
        +------------------------------+       |
        |                              |       |
        | ...                          |       |
        +------------------------------+       |
        | Rutina de manejo de          |       |
        | interrupción 2               |       |
        +------------------------------+       |
        | Rutina de manejo de          |&lt;----+ |
        | interrupción 1               |     | |
        +------------------------------+     | |
        | Rutina de manejo de          | &lt;-+ | |
        | interrupción 0               |   | | |
        +------------------------------+   | | |
        |                              |   | | |
        |                              |   | | |
        |                              |   | | |
        +------------------------------+   | | |
        | Descriptor de Interrupción   |&lt;------+
        | 255                          |   | |  
        +------------------------------+   | |  
        | ...                          |   | |  
        |                              |   | |
        +------------------------------+   | |
        | Descriptor de Interrupción   |&lt;----+
        | 1                            |   |
        +------------------------------+   |
        | Descriptor de Interrupción   |&lt;--+
        | 0                            |
        +------------------------------+ &lt;--- Inicio de la Tabla de Descriptores
        |                              |      de Interrupción (IDT)
        |                              |
        |                              |
        |                              |
        |                              |
        +------------------------------+         </pre><p>La IDT está conformada por 256 descriptores, uno para cada interrupción. Cada descriptor ocupa 8 bytes, y puede ser de uno de los siguientes tipos:</p>
<ul>
<li>Task-Gate</li>
<li>Interrupt-Gate</li>
<li>Trap-Gate</li>
</ul>
<p>Cada entrada tiene el siguiente formato:</p>
<pre class="fragment"> 31                23               15--FLAGS---------- 7                0
 +-----------------------------------+-+-----+---------+-----+---------+
 |                                   | |     | TYPE    |  (ALWAYS 0)   |
 |           OFFSET 31..16           |P| DPL |0 D 1 1 0|0 0 0 0 0 0 0 0| 4
 |                                   | |     |         |               |
 +-----------------------------------+-+-----+---------+---------------+
 |                                   |                                 |
 |            SELECTOR               |          OFFSET 15..0           | 0
 |                                   |                                 |
 +-----------------------------------+---------------------------------+</pre><p>En donde:</p>
<ul>
<li>Offset: Desplazamiento (offset) en el cual se encuentra la rutina de manejo de interrupción (la dirección de memoria de la rutina) dentro de un segmento de código.</li>
<li>Selector: Selector que referencia al descriptor de segmento de código en la GDT dentro del cual se encuentra la rutina de manejo de interrupción.</li>
<li>D : Tipo de descriptor : (0=16 bits), (1=32 bits)</li>
<li>FLAGS : compuesto por los bits P (1 bit), DPL (2 bits) y TYPE (5 bits). Para un interrupt gate, el valor de FLAGS es 0x8E = 10001110 (P = 1, DPL = 0, D = 1)</li>
</ul>
<p>La dirección lógica segmento : offset que se obtiene del descriptor se traduce a una dirección lineal. Si la paginación se encuentra deshabilitada (por defecto), la dirección lineal es la misma dirección física en la cual se encuentra la rutina que atenderá la interrupción.</p>
<dl class="section user"><dt>Carga de la IDT</dt><dd></dd></dl>
<p>Para cargar la IDT se utiliza la instrucción de ensamblador </p>
<div class="fragment"><div class="line">lidt ptr_addr</div>
</div><!-- fragment --><p>La instrucción idt toma el puntero y lo carga en el registro IDTR del procesador. ptr_addr corresponde a la dirección de memoria en la cual se encuentra una estructura de datos que describe la IDT. Esta estructura de datos se denomina 'puntero a la IDT', 'IDT Pointer'.</p>
<p>El puntero al IDT tiene el siguiente formato: </p>
<pre class="fragment"> 47                  15              0
 +----------------------------------+
 |      base         |    límite    |
 +----------------------------------+</pre><p> en donde: base = dirección lineal de la IDT, que corresponde a la dirección de memoria de IDT.</p>
<p>límite = tamaño de la IDT en Bytes. Si la IDT tiene 256 entradas y el tamaño de cada entrada es de 8 bytes, el tamaño total de la IDT es de 2048 bytes (2 KB).</p>
<h1><a class="anchor" id="interrupt_handling"></a>
Gestión de Interrupciones en IA-32</h1>
<p>Cuando ocurre la interrupción N, el procesador busca la entrada N dentro de la IDT, y de ella obtiene la dirección lineal de la rutina de manejo de la interrupción N a la cual se debe pasar el control.</p>
<p>Antes de pasar el control a la rutina de manejo de interrupción, el procesador almacena en el tope de la pila el valor de EFLAGS, CS y EIP en este orden. Esto permitirá ejecutar la rutina de manejo de interrupción y luego continuar la ejecución en el punto exacto en el que se interrumpió al procesador.</p>
<p>Si la interrupción genera un código de error (algunas de las excepciones de IA-32), este código de error también se inserta en la pila.</p>
<p>A continuación se ilustra el estado de la pila en el momento de pasar el control a la rutina de manejo de interrupción.</p>
<ol type="1">
<li>Cuando ocurre una interrupción que no tiene código de error: <pre class="fragment">      Estado de la pila en el momento  de pasar el control a la rutina de manejo
      de interrupción

      +--------------------+    
      |  valor             |                                       
      +--------------------+ &lt;- SS: ESP antes de ocurrir la interrupción
      | EFLAGS             |    
      +--------------------+     
      | CS                 |     
      +--------------------+
      | EIP                |  
      +--------------------+ &lt;- SS: ESP al momento de pasar el control a la 
      | Espacio            |   rutina de manejo de interrupción
      | disponible en la   |
      | pila               |  
      |                    |
      |                    |
      +--------------------+ &lt;---  Base de la pila
      |                    |
      |                    |
      +--------------------+
</pre> Si el segmento de código en el cual se encuentra la rutina de manejo de interrupción tiene un nivel de privilegios (DPL) diferente al nivel de privilegios del segmento de código en el que se encuentra el código interrumpido, ocurre un "Cambio de Contexto" de pila. El procesador almacena primero SS y ESP, y luego almacena EFLAGS, CS e IP en la pila. <pre class="fragment">    +--------------------------+
    | valor en la pila         | Pila del código (o tarea) antes de ocurrir la
    |--------------------------| interrupción o excepción                  
    | valor en la pila         |            
    +--------------------------+  &lt;-- OLD SS: OLD ESP --+
                                                        |
                                                        |
 +------------------------------------------------------+
 |  +--------------------------+
 |  | old ss                   | Estos valores son almacenados automáticamente
 |  |--------------------------| en la pila cuando ocurre una interrupción
 +--|--&gt; old esp               | o excepción y hay cambio de privilegios
    |--------------------------| ..
    | eflags                   | ..
    |--------------------------| ..
    | old cs                   | ..
    |--------------------------| ..
    | old eip                  | ..
    +--------------------------+  &lt;-- ESP</pre></li>
<li>Cuando ocurre una interrupción que tiene código de error asociado: <pre class="fragment">      Estado de la pila en el momento  de pasar el control a la rutina de manejo
      de interrupción

      +--------------------+    
      |  valor             |                                       
      +--------------------+ &lt;- SS: ESP antes de ocurrir la interrupción
      | EFLAGS             |    
      +--------------------+     
      | CS                 |     
      +--------------------+
      | EIP                |     
      +--------------------+
      | Código de error    |  
      +--------------------+ &lt;- SS: ESP al momento de pasar el control a la 
      | Espacio            |        rutina de manejo de interrupción
      | disponible en la   |
      | pila               |  
      |                    |
      |                    |
      +--------------------+ &lt;---  Base de la pila
      |                    |
      |                    |
      +--------------------+
</pre> Si el segmento de código en el cual se encuentra la rutina de manejo de interrupción tiene un nivel de privilegios (DPL) diferente al nivel de privilegios del segmento de código en el que se encuentra el código interrumpido, ocurre un "Cambio de Contexto" de pila. El procesador almacena primero SS y ESP, y luego almacena EFLAGS, CS e IP en la pila. <pre class="fragment">    +--------------------------+
    | valor en la pila         | Pila del código (o tarea) antes de ocurrir la
    |--------------------------| interrupción o excepción                  
    | valor en la pila         |            
    +--------------------------+  &lt;-- OLD SS: OLD ESP --+
                                                        |
                                                        |
 +------------------------------------------------------+
 |  +--------------------------+
 |  | old ss                   | Estos valores son almacenados automáticamente
 |  |--------------------------| en la pila cuando ocurre una interrupción
 +--|--&gt; old esp               | o excepción y hay cambio de privilegios
    |--------------------------| ..
    | eflags                   | ..
    |--------------------------| ..
    | old cs                   | ..
    |--------------------------| ..
    | old eip                  | ..
    |--------------------------| ..
    | Código de error          | ..
    +--------------------------+  &lt;-- ESP</pre></li>
</ol>
<p>Con el fin de mantener un marco de pila uniforme, se inserta un código de error de cero en la pila para aquellas interrupciones que no generan codigo de error.</p>
<h1><a class="anchor" id="interrupt_handler_routines"></a>
Rutinas de manejo de interrupción (ISR)</h1>
<p>Las rutinas de manejo de interrupción son el elemento más cercano al hardware. Estas rutinas deben interactuar directamente con los registros del procesador, por lo cual se implementan en lenguaje ensamblador. Su tarea consiste en guardar el estado del procesador (el valor de todos sus registros), y luego invocar el código en C que manejará la interrupción. Después se deberá recuperar el estado del procesador y retornar mediante la instrucción <b>iret</b>.</p>
<p>A continuación se presentan ejemplos de rutinas de manejo de interrupción.</p>
<ul>
<li>Rutina para el manejo de la interrupción 5 (no genera código de error) <pre class="fragment">isr5:
   /* Deshabilitar las interrupciones*/
  cli
  /* Ahora se crea un marco de pila estandar para invocar la rutina general
  interrupt_dispatcher. */
  /* Codigo de error = 0 */
 push 0
 /* # de excepcion generada */
 push 5 
 /* Almacenar en la pila los registros de propósito general en el siguiente
 orden: eax, ecx, edx, ebx, esp original, ebp, esi, y edi */
 pusha
 /* Almacenar en la pila los registros de segmento de datos */
 push ds
 push es
 push fs
 push gs

 /* Este marco de pila se crea en el contexto de ejecución actual. */

 /*
 La pila luce así:
 +--------------------------+
 | old SS                   |  (Si ocurre un cambio de contexto de pila)
 |--------------------------|  
 | old ESP                  |  (Si ocurre un cambio de contexto de pila)
 |--------------------------| ..
 | EFLAGS                   | Estos valores son almacenados automáticamente
 |--------------------------| en la pila cuando ocurre una interrupción
 | old CS                   | ..
 |--------------------------| ..
 | old EIP                  | ..
 |--------------------------| -------------------------------------------
 | 0 (código de error)      | push 0 (código de error = 0)
 |--------------------------|
 | # de excepción generada  | push \id
 |--------------------------|
 | EAX                      | pusha
 |--------------------------|
 | ECX                      |(recuerde que pusha almacena en la pila los
 |--------------------------|registros en el siguiente orden:
 | EDX                      |eax, ecx, edx, ebx, esp original, ebp, esi,
 |--------------------------|edi)
 | EBX                      |
 |--------------------------|
 | ESP antes de pusha       |
 |--------------------------|
 | EBP                      |
 |--------------------------|
 | ESI                      |
 |--------------------------|
 | EDI                      |
 |--------------------------|------------------------------------------
 | DS                       | ahora los registros de segmento de datos
 |--------------------------|
 | ES                       |
 |--------------------------|
 | FS                       |
 |--------------------------|
 | GS                       |
 |--------------------------|&lt;-- ESP 
 */

    /* Configurar los registros de segmento de datos para que contengan
 el selector de datos para el kernel definido en la GDT */
 movw ax, KERNEL_DATA_SELECTOR
 mov ds, ax
 mov es, ax
 mov fs, ax
 mov gs, ax
 
 /* Almacenar la posición actual del apuntador de la pila ss:esp */
 mov [current_ss], ss
 mov [current_esp], esp

 /* Invocar al código en C que manejará la interrupción */
 call interrupt_dispatcher
 
 /* Recuperar el apuntador de la pila ss:esp almacenado luego de crear
 el marco de pila para la interrupción */
 mov ss, [current_ss]
 mov esp, [current_esp]
 
 /* Ahora sacar los parámetros enviados a la pila en orden inverso */
 pop gs
 pop fs
 pop es
 pop ds
 /* los registros de propósito general */
 popa
 
 /* Código de error e interrupcion generada */
 add esp, 8

 /*
 Ahora la pila luce asi:
 +--------------------------+
 | old ss                   | Si ocurrió un cambio de contexto de pila,
 |--------------------------| se almacena la posición de la pila anterior
 | old esp                  | (SS:ESP).
 |--------------------------| 
 | eflags                   | Estado del procesador (EFLAGS)
 |--------------------------| 
 | old cs                   | Dirección lineal CS:EIP a la cual se debe
 |--------------------------| retornar (punto en el cual se interrumpió
 | old eip                  | el procesador)
 +--------------------------+ &lt;-- ESP (tope de la pila)
 */

 /* Retornar de la interrupcion */
 iret
 /* Esta rutina 'no retorna', ya que continua la ejecucion en el contexto
 que fue interrumpido. */</pre></li>
<li>Rutina para el manejo de la interrupción 7 (genera código de error) <pre class="fragment">isr7:
   /* Deshabilitar las interrupciones*/
  cli
  /* Ahora se crea un marco de pila estandar para invocar la rutina general
  interrupt_dispatcher. */
  /* El código de error es almacenado  por el procesador en la pila
  de forma automática cuando ocurre la excepcion
  */
 /* # de excepcion generada */
 push 7 
 /* Almacenar en la pila los registros de propósito general en el siguiente
 orden: eax, ecx, edx, ebx, esp original, ebp, esi, y edi */
 pusha
 /* Almacenar en la pila los registros de segmento de datos */
 push ds
 push es
 push fs
 push gs

 /* Este marco de pila se crea en el contexto de ejecución actual. */

 /*
 La pila luce así:
 +--------------------------+
 | old SS                   |  (Si ocurre un cambio de contexto de pila)
 |--------------------------|  
 | old ESP                  |  (Si ocurre un cambio de contexto de pila)
 |--------------------------| ..
 | EFLAGS                   | Estos valores son almacenados automáticamente
 |--------------------------| en la pila cuando ocurre una interrupción
 | old CS                   | ..
 |--------------------------| ..
 | old EIP                  | ..
 |--------------------------| -------------------------------------------
 | (código de error)        | push 0 (código de error = 0)
 |--------------------------|
 | # de excepción generada  | push \id
 |--------------------------|
 | EAX                      | pusha
 |--------------------------|
 | ECX                      |(recuerde que pusha almacena en la pila los
 |--------------------------|registros en el siguiente orden:
 | EDX                      |eax, ecx, edx, ebx, esp original, ebp, esi,
 |--------------------------|edi)
 | EBX                      |
 |--------------------------|
 | ESP antes de pusha       |
 |--------------------------|
 | EBP                      |
 |--------------------------|
 | ESI                      |
 |--------------------------|
 | EDI                      |
 |--------------------------|------------------------------------------
 | DS                       | ahora los registros de segmento de datos
 |--------------------------|
 | ES                       |
 |--------------------------|
 | FS                       |
 |--------------------------|
 | GS                       |
 |--------------------------|&lt;-- ESP 
 */

    /* Configurar los registros de segmento de datos para que contengan
 el selector de datos para el kernel definido en la GDT */
 movw ax, KERNEL_DATA_SELECTOR
 mov ds, ax
 mov es, ax
 mov fs, ax
 mov gs, ax
 
 /* Almacenar la posición actual del apuntador de la pila ss:esp */
 mov [current_ss], ss
 mov [current_esp], esp

 /* Invocar al código en C que manejará la interrupción */
 call interrupt_dispatcher
 
 /* Recuperar el apuntador de la pila ss:esp almacenado luego de crear
 el marco de pila para la interrupción */
 mov ss, [current_ss]
 mov esp, [current_esp]
 
 /* Ahora sacar los parámetros enviados a la pila en orden inverso */
 pop gs
 pop fs
 pop es
 pop ds
 /* los registros de propósito general */
 popa
 /* Código de error e interrupcion generada */
 add esp, 8

 /*
 Ahora la pila luce asi:
 +--------------------------+
 | old ss                   | Si ocurrió un cambio de contexto de pila,
 |--------------------------| se almacena la posición de la pila anterior
 | old esp                  | (SS:ESP).
 |--------------------------| 
 | eflags                   | Estado del procesador (EFLAGS)
 |--------------------------| 
 | old cs                   | Dirección lineal CS:EIP a la cual se debe
 |--------------------------| retornar (punto en el cual se interrumpió
 | old eip                  | el procesador)
 +--------------------------+ &lt;-- ESP (tope de la pila)
 */

 /* Retornar de la interrupcion */
 iret
 /* Esta rutina 'no retorna', ya que continua la ejecucion en el contexto
 que fue interrumpido. */</pre></li>
</ul>
<p>La función interrupt_dispatcher puede ser implementada en C y contener el código para manejar las interrupciones.</p>
<p>Un punto clave de la implementación de la rutina es el siguiente: </p>
<pre class="fragment">    /* Almacenar la posición actual del apuntador de la pila ss:esp */
 mov [current_ss], ss
 mov [current_esp], esp

 /* Invocar al código en C que manejará la interrupción */
 call interrupt_dispatcher
 
 /* Recuperar el apuntador de la pila ss:esp almacenado luego de crear
 el marco de pila para la interrupción */
 mov ss, [current_ss]
 mov esp, [current_esp]
</pre><p>Este código almacena en las variables globales del kernel current_ss y current_esp los valores de ss y esp, que permiten apuntar a la posición de la pila en la cual se almacenó el estado del procesador. Luego se puede invocar a la función en C <a class="el" href="../../d5/d05/idt_8c.html#a491194ab27dc6f0939626c92cf4b376e" title="Esta rutina recibe el control de la Rutina de Servicio de Interrupción (ISR) isr0, isr1.. etc. correspondiente. Su trabajo consiste en determinar el vector de interrupción a partir del estado que recibe como parametro, y de invocar la rutina de manejo de interrupción adecuada, si existe.">interrupt_dispatcher()</a>. Esta función contendrá el código para manejar, y dado que current_ss y current_esp son variables globales, podrá tener acceso al estado del procesador en el momento en que ocurrió la interrupción.</p>
<p>Cuando <a class="el" href="../../d5/d05/idt_8c.html#a491194ab27dc6f0939626c92cf4b376e" title="Esta rutina recibe el control de la Rutina de Servicio de Interrupción (ISR) isr0, isr1.. etc. correspondiente. Su trabajo consiste en determinar el vector de interrupción a partir del estado que recibe como parametro, y de invocar la rutina de manejo de interrupción adecuada, si existe.">interrupt_dispatcher()</a> retorna, se recupera el apuntador a la pila en la posición en la cual se almacenó el estado del procesador. De esa posición se recupera el estado de los registros a sus valores en el momento en que ocurrió la interrupción, se extrae también el código de error. </p>
<pre class="fragment">/* Recuperar el apuntador de la pila ss:esp almacenado luego de crear
 el marco de pila para la interrupción */
 mov ss, [current_ss]
 mov esp, [current_esp]
 
 /* Ahora sacar los parámetros enviados a la pila en orden inverso */
 pop gs
 pop fs
 pop es
 pop ds
 /* los registros de propósito general */
 popa
 /* Código de error e interrupcion generada */
 add esp, 8
</pre><p>Ahora en el tope de la pila se encuentra la posición de memoria a la cual se debe retornar de la interrupción, y si ocurrió un cambio de contexto de pila también se encuentra</p>
<pre class="fragment"> +--------------------------+
 | old ss                   | Si ocurrió un cambio de contexto de pila,
 |--------------------------| se almacena la posición de la pila anterior
 | old esp                  | (SS:ESP).
 |--------------------------| 
 | eflags                   | Estado del procesador (EFLAGS)
 |--------------------------| 
 | old cs                   | Dirección lineal CS:EIP a la cual se debe
 |--------------------------| retornar (punto en el cual se interrumpió
 | old eip                  | el procesador)
 +--------------------------+ &lt;-- ESP (tope de la pila)
</pre><p>La instrucción </p>
<pre class="fragment">iret
</pre><p> Extrae el valor de EIP, CS y EFLAGS, y el valor de SS y ESP si ocurrió un cambio de contexto de pila. Con esto, la ejecución continúa exactamente en el sitio en el cual fue interrumpido el procesador.</p>
<dl class="section see"><dt>Ver también</dt><dd><a class="el" href="../../d4/d35/idt_8h.html" title="Contiene las definiciones globales requeridas para el manejo de interrupciones en la arquitectura IA-...">idt.h</a> Archivo con las definiciones necesarias para la gestión de interrupciones </dd>
<dd>
<a class="el" href="../../d5/df9/isr_8_s.html" title="Contiene la definicion y la implementacion de las rutinas de servicio de interrupcion para las 255 in...">isr.S</a> Archivo que contiene la implementación de las rutinas de manejo para las 256 interrupciones de IA-32 </dd>
<dd>
<a class="el" href="../../d5/d05/idt_8c.html" title="Este archivo implementa las primitivas para el manejo de interrupciones en la arquitectura IA-32...">idt.c</a> Archivo que contiene las rutinas para configurar y cargar la IDT y para gestionar las interrupciones. </dd>
<dd>
<a class="el" href="../../d8/dfe/gdt_page.html">Tabla Global de Descriptores - GDT</a> </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generado por &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
