<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Proyecto 10 - Gestión de Memoria Física: Gestión de Interrupciones, Excepciones e IRQ</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Proyecto 10 - Gestión de Memoria Física
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">Aprendiendo Sistemas Operativos</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Buscar');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Página&#160;principal</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Páginas&#160;relacionadas</span></a></li>
      <li><a href="../../modules.html"><span>Módulos</span></a></li>
      <li><a href="../../annotated.html"><span>Estructuras&#160;de&#160;Datos</span></a></li>
      <li><a href="../../files.html"><span>Archivos</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Buscar" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Todo</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Estructuras de Datos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Archivos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Funciones</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>&apos;typedefs&apos;</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>&apos;defines&apos;</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Grupos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Páginas</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Gestión de Interrupciones, Excepciones e IRQ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Autor</dt><dd>Erwin Meza Vega <a href="#" onclick="location.href='mai'+'lto:'+'eme'+'za'+'v@g'+'ma'+'il.'+'co'+'m'; return false;">emeza<span style="display: none;">.nosp@m.</span>v@gm<span style="display: none;">.nosp@m.</span>ail.c<span style="display: none;">.nosp@m.</span>om</a></dd></dl>
<p><a class="el" href="../../index.html#project_start">Información del Proyecto</a> : Gestión de Interrupciones, Excepciones e IRQ</p>
<p>En la arquitectura IA-32 se definen tres fuentes básicas de interrupción:</p>
<ul>
<li>Excepciones: Son condiciones de error que se presentan en la ejecución. Por ejemplo, al realizar una división por cero se lanza la excepción Division By Zero. Es una interrupción generada internamente por el procesador.</li>
<li>Interrupciones de los dispositivos de hardware (discos, teclado, floppy, etc). Los dispositivos de hardware realizan solicitudes de interrupción (Interrupt Request - IRQ). Cada IRQ tiene asociado un número de interrupción predefinido, pero es posible cambiarlo por programación.</li>
<li>Interrupciones por software, generadas mediante la instrucción <pre class="fragment">  int N
</pre> donde N es el número de interrupción.</li>
</ul>
<p>La arquitectura IA-32 soporta 256 interrupciones. De estas, las 32 primeras (número 0 a 31) se asignan por defecto a las excepciones del procesador.</p>
<p>A continuación se muestra una descripción de las interrupciones para IA-32.</p>
<pre class="fragment">Número de    | Descripción
Interrupción |
(dec/hex)    |
-------------|-------------------------------------------------
  0  0x00    | Divide error:
             | Ocurre durante una instrucción DIV, cuando el divisor
             | es cero o cuando ocurre un desbordamiento del cociente.
             | Esta excepción no genera código de error.

  1  0x01    | (Reservada)
             | Esta excepción no genera código de error.  

  2  0x02    | Nonmaskable interrupt:
             | Ocurre debido a una interrupcion de hardware que no se puede
             |  enmascarar.
             | Esta excepción no genera código de error.

  3  0x03    | Breakpoint:
             | Ocurre cuando el procesador encuentra una instrucción INT 3
             | Esta excepción no genera código de error.

  4  0x04    | Overflow:
             | Ocurre cuando el procesador encuentra una instrucción INTO
             | y el bit OF (Overflow) del registro EFLAGS se encuentra activo.
             | Esta excepción no genera código de error.

  5  0x05    | Bounds check (BOUND instruction):
             | Ocurre cuando el procesador, mientras ejecuta una instrucción
             | BOUND, encuentra que el operando excede el límite especificado.
             | Esta excepción no genera código de error.

  6  0x06    | Invalid opcode:
             | Ocurre cuando se detecta un código de operación inválido.
             | Esta excepción no genera código de error.

  7  0x07    | Device Not Available (No Math Coprocessor)
             | Ocurre para alguna de las dos condiciones:
             | - El procesador encuentra una instrucción ESC (Escape)
             |   y el bit EM (emulate) bit de CR0 (control register zero)
             |   se encuentra activo.
             | - El procesador encuentra una instrucción WAIT o una instrucción
             |   ESC y los bits MP (monitor coprocessor) y TS (task switched)
             |   del registro CR0 se encuentran activos.
             | Esta excepción no genera código de error.

  8  0x08    | Double fault:
             | Ocurre cuando el procesador detecta una excepción mientras trata
             | de invocar el manejador de una excepción anterior.
             | Esta excepción genera un código de error.

  9  0x09    | Coprocessor segment overrun:
             | Ocurre cuando se detecta una violación de página o segmento
             | mientras se transfiere la porción media de un operando de 
             | coprocesador al NPX.
             | Esta excepción no genera código de error.

 10  0xA     | Invalid TSS:
             | Ocurre si el TSS es inválido al tratar de cambiar de tarea (Task 
             |  switch).
             | Esta excepción genera código de error.

 11  0xB     | Segment not present:
             | Ocurre cuando el procesador detecta que el bit P (presente) de un
             | descriptor de segmento es cero.
             | Esta excepción genera código de error.

 12  0xC     | Stack exception:
             | Ocurre para las siguientes condiciones:
             | - Como resultado de una violación de límite en cualquier operación
             |   que se refiere al registro de segmento de pila (SS)
             | - Cuando se trata de establecer SS con un selector cuyo descriptor
             |   asociado se encuentra marcado como no presente, pero es válido
             | Esta excepción genera código de error.

 13  0xD     | General protection violation (GP):
             | Cada violación de protección que no causa otra excepción
             | causa una GP.
             | - Exceder el límite de segmento para CS, DS, ES, FS, o GS
             | - Exceder el límite de segmento cuando se referencia una tabla de
             |   descriptores
             | - Transferir el control a un segmento que no es ejecutable
             | - Escribir en un segmento de datos de sólo lectura o en un 
             |   segmento de código
             | - Leer de un segmento marcado como sólo de ejecución
             | - Cargar en SS un selector que referencia a un segmento de sólo 
             |   lectura
             | - Cargar SS, DS, ES, FS, o GS con un selector que referencia a un
             |   descriptor de tipo "sistema"
             | - Cargar DS, ES, FS, o GS con un selector que referencia a un 
             |   descriptor de segmento marcado como ejecutable que además no se
             |   puede leer
             | - Cargar en SS un selector que referencia un descriptor  de 
             |   segmento ejecutable
             | - Acceder a la memoria por medio de DS, ES, FS, o GS cuando estos
             |   registros de segmento contienen un selector nulo
             | - Pasar la ejecución (task switch) a una tarea marcada como "Busy"
             | - Violar las reglas de privilegios
             | - Cargar CR0 con los bits PG=1 y PE=0 (habilitar la paginación y
             |      no habilitar el modo protegido)
             | - Lanzar una interrupción o una excepción a través de un trap 
             |   gate desde Modo Virtual 8086 a un privilegio (DPL) diferente 
             |   de cero 
             | Esta excepción genera código de error.

 14  0xE     | Page fault:
             | Ocurre cuando la paginación está habilitada (PG = 1) en CR0
             | y el procesador detecta alguna de las siguientes condiciones
             | cuando trata de traducir una dirección lineal a física:
             | - El directorio de tabla de páginas o la tabla de páginas requerido
             |   para realizar la traducción tiene 0 en su bit de presente (P)
             | - El procedimiento actual no tiene los suficientes privilegios para
             |   acceder la página indicada.
             | Esta excepción genera código de error.

 15  0xF     | (Reservada)
             | Esta excepción no genera código de error.

 16  0x10    | x87 FPU Floating-Point Error (Math Fault)
             | Ocurre cuando el procesador detecta una señal del coprocesador en el
             | pin de entrada ERROR#.

 17  0x11    | Alignment Check
             | Ocurre cuando se realiza una referencia de datos en la memoria a 
             | una región no alineada.
             | Esta excepción genera código de error.
 
 18  0x12    | Machine Check
             | Depende del modelo y las características del procesador.
             | Esta excepción no genera código de error.
          
 19  0x23    | SIMD Floating-Point Exception
             | Ocurre cuando existe un error en las instrucciones SSE/SSE2/SSE3.
             | Esta excepción no genera código de error.
          

 20  0x24    | Reservadas por Intel.
  hasta      |
 31  0x1F    | Estas excepciones no generan código de error.
             |
             
              
 32  0x20    | Interrupción externa o interrupción invocada mediante la
  hasta      | instrucción INT N
 255 0xFF    | Estas interrupciones no generan código de error</pre> <dl class="section note"><dt>Nota</dt><dd>Tabla adaptada de Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 3A: System Programming Guide, Part 1. Sección 5.3.1.</dd></dl>
<h1><a class="anchor" id="idt_structure"></a>
Tabla de Descriptores de Interrupción (IDT)</h1>
<p>La IDT es una estructura de datos que usa el procesador en el momento en que ocurre la interrupción, y que debe estar configurada antes de habilitar las interrupciones. Es una tabla que contiene una serie de entradas denominadas "descriptores", que definen entre otros parámetros la dirección de memoria en la cual se encuentra cada rutina de manejo de interrupción.</p>
<p>El siguiente esquema muestra la IDT y las rutinas de manejo de interrupción en memoria:</p>
<pre class="fragment">        +------------------------------+
        |                              |
        |                              |
        +------------------------------+
        | Rutina de manejo de          |&lt;------+
        | interrupción 255             |       |
        +------------------------------+       |
        |                              |       |
        | ...                          |       |
        +------------------------------+       |
        | Rutina de manejo de          |       |
        | interrupción 2               |       |
        +------------------------------+       |
        | Rutina de manejo de          |&lt;----+ |
        | interrupción 1               |     | |
        +------------------------------+     | |
        | Rutina de manejo de          | &lt;-+ | |
        | interrupción 0               |   | | |
        +------------------------------+   | | |
        |                              |   | | |
        |                              |   | | |
        |                              |   | | |
        +------------------------------+   | | |
        | Descriptor de Interrupción   |&lt;------+
        | 255                          |   | |  
        +------------------------------+   | |  
        | ...                          |   | |  
        |                              |   | |
        +------------------------------+   | |
        | Descriptor de Interrupción   |&lt;----+
        | 1                            |   |
        +------------------------------+   |
        | Descriptor de Interrupción   |&lt;--+
        | 0                            |
        +------------------------------+ &lt;--- Inicio de la Tabla de Descriptores
        |                              |      de Interrupción (IDT)
        |                              |
        |                              |
        |                              |
        |                              |
        +------------------------------+         </pre><p>La IDT está conformada por 256 descriptores, uno para cada interrupción. Cada descriptor ocupa 8 bytes, y puede ser de uno de los siguientes tipos:</p>
<ul>
<li>Task-Gate</li>
<li>Interrupt-Gate</li>
<li>Trap-Gate</li>
</ul>
<p>Cada entrada tiene el siguiente formato:</p>
<pre class="fragment"> 31                23               15--FLAGS---------- 7                0
 +-----------------------------------+-+-----+---------+-----+---------+
 |                                   | |     | TYPE    |  (ALWAYS 0)   |
 |           OFFSET 31..16           |P| DPL |0 D 1 1 0|0 0 0 0 0 0 0 0| 4
 |                                   | |     |         |               |
 +-----------------------------------+-+-----+---------+---------------+
 |                                   |                                 |
 |            SELECTOR               |          OFFSET 15..0           | 0
 |                                   |                                 |
 +-----------------------------------+---------------------------------+</pre><p>En donde:</p>
<ul>
<li>Offset: Desplazamiento (offset) en el cual se encuentra la rutina de manejo de interrupción (la dirección de memoria de la rutina) dentro de un segmento de código.</li>
<li>Selector: Selector que referencia al descriptor de segmento de código en la GDT dentro del cual se encuentra la rutina de manejo de interrupción.</li>
<li>D : Tipo de descriptor : (0=16 bits), (1=32 bits)</li>
<li>FLAGS : compuesto por los bits P (1 bit), DPL (2 bits) y TYPE (5 bits). Para un interrupt gate, el valor de FLAGS es 0x8E = 10001110 (P = 1, DPL = 0, D = 1)</li>
</ul>
<p>La dirección lógica segmento : offset que se obtiene del descriptor se traduce a una dirección lineal. Si la paginación se encuentra deshabilitada (por defecto), la dirección lineal es la misma dirección física en la cual se encuentra la rutina que atenderá la interrupción.</p>
<dl class="section user"><dt>Carga de la IDT</dt><dd></dd></dl>
<p>Para cargar la IDT se utiliza la instrucción de ensamblador </p>
<div class="fragment"><div class="line">lidt ptr_addr</div>
</div><!-- fragment --><p>La instrucción idt toma el puntero y lo carga en el registro IDTR del procesador. ptr_addr corresponde a la dirección de memoria en la cual se encuentra una estructura de datos que describe la IDT. Esta estructura de datos se denomina 'puntero a la IDT', 'IDT Pointer'.</p>
<p>El puntero al IDT tiene el siguiente formato: </p>
<pre class="fragment"> 47                  15              0
 +----------------------------------+
 |      base         |    límite    |
 +----------------------------------+</pre><p> en donde: base = dirección lineal de la IDT, que corresponde a la dirección de memoria de IDT.</p>
<p>límite = tamaño de la IDT en Bytes. Si la IDT tiene 256 entradas y el tamaño de cada entrada es de 8 bytes, el tamaño total de la IDT es de 2048 bytes (2 KB).</p>
<h1><a class="anchor" id="interrupt_management"></a>
Gestión de Interrupciones en IA-32</h1>
<p>Cuando ocurre una interrupción (0 a 255), el procesador busca en la IDT la rutina que la atenderá. La función <a class="el" href="../../d4/d35/idt_8h.html#a9782031a7d6cb759022b58789382f5eb" title="Esta rutina se encarga de cargar la IDT.">setup_idt()</a> ha configurado la IDT para que se ejecute la rutina isrN cuando ocurre la interrupción N. Estas rutinas se definen en ensamblador en el archivo <a class="el" href="../../d5/df9/isr_8_s.html" title="Contiene la definicion y la implementacion de las rutinas de servicio de interrupcion para las 255 in...">isr.S</a>.</p>
<p>Las rutinas isr0 ... isr255 almacenan el estado actual del procesador, y también el número de la interrupción que ocurrió. Estas rutinas guardan el apuntador al tope de la pila en el cual se encuentra el estado del procesador en las variables globales current_ss y current_esp, y luego invocan a la función <a class="el" href="../../d5/d05/idt_8c.html#a491194ab27dc6f0939626c92cf4b376e" title="Esta rutina recibe el control de la Rutina de Servicio de Interrupción (ISR) isr0, isr1.. etc. correspondiente. Su trabajo consiste en determinar el vector de interrupción a partir del estado que recibe como parametro, y de invocar la rutina de manejo de interrupción adecuada, si existe.">interrupt_dispatcher()</a> implementada en <a class="el" href="../../d5/d05/idt_8c.html" title="Este archivo implementa las primitivas para el manejo de interrupciones en la arquitectura IA-32...">idt.c</a>.</p>
<p>La rutina interrupt_dispatcher toma el marco de pila y extrae el número de la interrupción que ocurrió. Con este valor busca dentro de la tabla de manejadores de interrupción (la variable <a class="el" href="../../d5/d05/idt_8c.html#adc7a0623aadf5f38415f8847cb297c86">interrupt_handlers</a>) el apuntador a la rutina que manejará la interrupción correspondiente.</p>
<p>Si encuentra un apuntador válido, invoca la rutina de manejo de interrupción. Cuando esta rutina termina, retorna de nuevo el control a <a class="el" href="../../d5/d05/idt_8c.html#a491194ab27dc6f0939626c92cf4b376e" title="Esta rutina recibe el control de la Rutina de Servicio de Interrupción (ISR) isr0, isr1.. etc. correspondiente. Su trabajo consiste en determinar el vector de interrupción a partir del estado que recibe como parametro, y de invocar la rutina de manejo de interrupción adecuada, si existe.">interrupt_dispatcher()</a>.</p>
<p>A su vez, <a class="el" href="../../d5/d05/idt_8c.html#a491194ab27dc6f0939626c92cf4b376e" title="Esta rutina recibe el control de la Rutina de Servicio de Interrupción (ISR) isr0, isr1.. etc. correspondiente. Su trabajo consiste en determinar el vector de interrupción a partir del estado que recibe como parametro, y de invocar la rutina de manejo de interrupción adecuada, si existe.">interrupt_dispatcher()</a> retorna a la función isrN que la invocó.</p>
<p>Luego, la función isrN invoca a la función return_from_interrupt() (<a class="el" href="../../d5/df9/isr_8_s.html" title="Contiene la definicion y la implementacion de las rutinas de servicio de interrupcion para las 255 in...">isr.S</a>), la cual recupera el estado del procesador y retorna de la interrupción al sitio en el cual la ejecución fue interrumpida.</p>
<pre class="fragment">             Esquema general del Manejo de Interrupciones

   La función interrupt_dispatcher()              +-----------------------+
   busca dentro del arreglo                       |                       |
   interrupt_handlers                     +------&gt;| Función para atender  |
   el apuntador a la rutina de            |       | la interrupción N     |
   manejo de interrupción                 |       |                       |
   (handler) N.                           |   +---+-----------------------+
                                          |   |               
interrupt_handlers (idt.c)                |   v
   +--------------------------------------------------------------------------+
   | * handler 0 | * handler 1 | ... | *handler N | ...  | ...  | handler 255 |
   +--------------------------------------------------------------------------+ 
                                         |   |  La función de manejo de 
      Todas las ISR establecen un        |   |  interrupción retorna el control
      marco de pila estándar e           |&lt;--+        
      invocan a la función          interrupt_dispatcher()
      interrupt_dispatcher()             ^   
                                         |--------+------+--------------+
IDT (idt.c)                              |        |      |              |
    +------------------------------------------------------------------------+
    | isr0 | isr1 | ... | isr31 | ... | isrN  | isr47 | isr48 | ... | isr255 |
    +------------------------------------------------------------------------+
                                        ^
                                        |
                        Interrupción N -+</pre><dl class="section user"><dt>Instalar y Desinstalar Manejadores de Interrupción</dt><dd></dd></dl>
<p>Para instalar un nuevo manejador de interrupción, se debe invocar a la función <a class="el" href="../../d5/d05/idt_8c.html#a889ba321f899261c91e92feae534fb70" title="Instala un nuevo manejador de interrupción para un número de interrupción determinado.">install_interrupt_handler()</a> definida en el archivo <a class="el" href="../../d5/d05/idt_8c.html" title="Este archivo implementa las primitivas para el manejo de interrupciones en la arquitectura IA-32...">idt.c</a>. Esta función recibe como parámetro el número de interrupción, y el apuntador a la rutina que manejará la interrupción. Este apuntador se almacena en la posición correspondiente en el arreglo (la tabla) <a class="el" href="../../d5/d05/idt_8c.html#adc7a0623aadf5f38415f8847cb297c86">interrupt_handlers</a>.</p>
<p>Para desinstalar un manejador de interrupción, se debe especificar el número de interrupción. Esta función elimina el apuntador correspondiente en el arreglo (la tabla) <a class="el" href="../../d5/d05/idt_8c.html#adc7a0623aadf5f38415f8847cb297c86">interrupt_handlers</a>.</p>
<h1><a class="anchor" id="exception_management"></a>
Gestión de Excepciones</h1>
<p>Para gestionar las excepciones se agrega una capa de abstracción adicional. Luego de configurar las 255 rutinas manejadoras de interrupción (<a class="el" href="../../d4/d35/idt_8h.html#a9782031a7d6cb759022b58789382f5eb" title="Esta rutina se encarga de cargar la IDT.">setup_idt()</a>) el código del kernel en <a class="el" href="../../d7/d9f/doc__bitmap_2kernel_8c.html#ac81b272b403fb3e4a4c5c1cc389b4195" title="Función principal del kernel. Esta rutina recibe el control del codigo en ensamblador de start...">cmain()</a> invoca a la función <a class="el" href="../../dd/d2d/exception_8h.html#aeabb6fee229c6885f9e32c8d9cf7e8c4" title="Esta rutina crea un manejador de interrupcion para las 32 excepciones x86 e inicializa la tabla de ma...">setup_exceptions()</a>.</p>
<p>Esta función configura las entradas 0 a 31 de la tabla interrupt_handlers con apuntadores a la función <a class="el" href="../../d4/d43/exception_8c.html#acccb5e3de60f72eacd7efb046ec6c267" title="Esta rutina recibe el control de la interrupt_dispatcher. Su trabajo consiste en determinar el vector...">exception_dispatcher()</a>. Esta función permite centralizar la gestión de excepciones.</p>
<p>De forma similar al arreglo <a class="el" href="../../d5/d05/idt_8c.html#adc7a0623aadf5f38415f8847cb297c86">interrupt_handlers</a> de <a class="el" href="../../d5/d05/idt_8c.html" title="Este archivo implementa las primitivas para el manejo de interrupciones en la arquitectura IA-32...">idt.c</a> que permite almacenar los apuntadores a las funciones que manejarán las 255 interrupciones IA-32, en el archivo <a class="el" href="../../d4/d43/exception_8c.html" title="Este archivo implementa las primitivas necesarias para el manejo de excepciones en la arquitectura IA...">exception.c</a> se define el arreglo (la tabla) <a class="el" href="../../d4/d43/exception_8c.html#a3ec3c1e26fba0c6c7090e0d70b805459">exception_handlers</a> que almacena los apuntadores a las funciones que manejarán las 32 excepciones IA-32.</p>
<dl class="section user"><dt>Proceso de gestión de una excepción</dt><dd></dd></dl>
<p>A continuación se describe el proceso para gestionar una excepción.</p>
<ol type="1">
<li>Cuando ocurre una excepción N (interrupción 0 a 31), se ejecuta la rutina isrN ( 0 &lt;= N &lt;= 31) correspondiente (configurada en <a class="el" href="../../d4/d35/idt_8h.html#a9782031a7d6cb759022b58789382f5eb" title="Esta rutina se encarga de cargar la IDT.">setup_idt()</a>).</li>
<li>La rutina isrN crea el marco de pila en el cual almacena el estado del procesador, guarda el apuntador actual a la pila (current_ss y current_esp) e invoca a la función <a class="el" href="../../d5/d05/idt_8c.html#a491194ab27dc6f0939626c92cf4b376e" title="Esta rutina recibe el control de la Rutina de Servicio de Interrupción (ISR) isr0, isr1.. etc. correspondiente. Su trabajo consiste en determinar el vector de interrupción a partir del estado que recibe como parametro, y de invocar la rutina de manejo de interrupción adecuada, si existe.">interrupt_dispatcher()</a>.</li>
<li>La función <a class="el" href="../../d5/d05/idt_8c.html#a491194ab27dc6f0939626c92cf4b376e" title="Esta rutina recibe el control de la Rutina de Servicio de Interrupción (ISR) isr0, isr1.. etc. correspondiente. Su trabajo consiste en determinar el vector de interrupción a partir del estado que recibe como parametro, y de invocar la rutina de manejo de interrupción adecuada, si existe.">interrupt_dispatcher()</a> busca dentro de la tabla <a class="el" href="../../d5/d05/idt_8c.html#adc7a0623aadf5f38415f8847cb297c86">interrupt_handlers</a> el apuntador a la rutina de manejo de interrupción. Debido a que la función <a class="el" href="../../dd/d2d/exception_8h.html#aeabb6fee229c6885f9e32c8d9cf7e8c4" title="Esta rutina crea un manejador de interrupcion para las 32 excepciones x86 e inicializa la tabla de ma...">setup_exceptions()</a> ha configurado las entradas 0 a 31 para que apunten a la función <a class="el" href="../../d4/d43/exception_8c.html#acccb5e3de60f72eacd7efb046ec6c267" title="Esta rutina recibe el control de la interrupt_dispatcher. Su trabajo consiste en determinar el vector...">exception_dispatcher()</a> (<a class="el" href="../../d4/d43/exception_8c.html" title="Este archivo implementa las primitivas necesarias para el manejo de excepciones en la arquitectura IA...">exception.c</a>), se invoca esta función.</li>
<li>La función <a class="el" href="../../d4/d43/exception_8c.html#acccb5e3de60f72eacd7efb046ec6c267" title="Esta rutina recibe el control de la interrupt_dispatcher. Su trabajo consiste en determinar el vector...">exception_dispatcher()</a> busca dentro de la tabla <a class="el" href="../../d4/d43/exception_8c.html#a3ec3c1e26fba0c6c7090e0d70b805459">exception_handlers</a> el apuntador a la función que manejará la excepción correspondiente (que se configura con la función <a class="el" href="../../d4/d43/exception_8c.html#a20e07f41764b9b872a45208a9a3900d7" title="Esta rutina permite definir un nuevo manejador de excepcion para una de las excepciones de los proces...">install_exception_handler()</a> en el archivo <a class="el" href="../../d4/d43/exception_8c.html" title="Este archivo implementa las primitivas necesarias para el manejo de excepciones en la arquitectura IA...">exception.c</a>). Si existe un manejador de excepción, se invoca. En caso contrario, imprime un error y entra en un ciclo infinito.</li>
<li>Cuando la rutina de manejo de excepción termina, retorna el control a la función <a class="el" href="../../d4/d43/exception_8c.html#acccb5e3de60f72eacd7efb046ec6c267" title="Esta rutina recibe el control de la interrupt_dispatcher. Su trabajo consiste en determinar el vector...">exception_dispatcher()</a>. Esta a su vez retorna el control a <a class="el" href="../../d5/d05/idt_8c.html#a491194ab27dc6f0939626c92cf4b376e" title="Esta rutina recibe el control de la Rutina de Servicio de Interrupción (ISR) isr0, isr1.. etc. correspondiente. Su trabajo consiste en determinar el vector de interrupción a partir del estado que recibe como parametro, y de invocar la rutina de manejo de interrupción adecuada, si existe.">interrupt_dispatcher()</a>, la cual retorna a la función isrN definida en <a class="el" href="../../d5/df9/isr_8_s.html" title="Contiene la definicion y la implementacion de las rutinas de servicio de interrupcion para las 255 in...">isr.S</a>.</li>
<li>Luego de recibir el control de <a class="el" href="../../d5/d05/idt_8c.html#a491194ab27dc6f0939626c92cf4b376e" title="Esta rutina recibe el control de la Rutina de Servicio de Interrupción (ISR) isr0, isr1.. etc. correspondiente. Su trabajo consiste en determinar el vector de interrupción a partir del estado que recibe como parametro, y de invocar la rutina de manejo de interrupción adecuada, si existe.">interrupt_dispatcher()</a>, la rutina isrN invoca a la función return_from_interrupt() definida en <a class="el" href="../../d5/df9/isr_8_s.html" title="Contiene la definicion y la implementacion de las rutinas de servicio de interrupcion para las 255 in...">isr.S</a>. Esta función recupera el estado del procesador y retorna al sitio en el cual el procesador fue interrumpido.</li>
</ol>
<pre class="fragment">             Esquema general del Manejo de Excepciones
             
             
 La función exception_dispatcher()                +-----------------------+
   busca dentro del arreglo                       | Rutina de manejo de   |
   exception_handlers                     +------&gt;| la excepción N        |
   el apuntador a la rutina de            |       |                       |
   manejo de excepción                    |       |                       |
   (handler) N.                           |   +---+-----------------------+
                                          |   |               
exception_handlers (exception.c)          |   v
   +--------------------------------------------------------------------------+
   | * handler 0 | * handler 1 | ... | *handler N | ...  | ...  | handler 31  |
   +--------------------------------------------------------------------------+
                                           ^    | 
                                           | |
                                           N    |
                                           |    v
                                           +-----------------+          
                                                             |
   La función interrupt_dispatcher()              +-----------------------+
   busca dentro del arreglo                       | Las entradas 0 a 31   |
   interrupt_handlers                     +------&gt;| de interrupt_handlers |
   el apuntador a la rutina de            |       | apuntan a la rutina   |
   manejo de interrupción                 |       | exception_dispatcher  |
   (handler) N.                           |   +---+-----------------------+
                                          |   |               
interrupt_handlers (idt.c)                |   v
   +--------------------------------------------------------------------------+
   | * handler 0 | * handler 1 | ... | *handler N | ...  | ...  | handler 255 |
   +--------------------------------------------------------------------------+ 
                                         |   |  La función de manejo de 
      Todas las ISR establecen un        |   |  interrupción retorna el control
      marco de pila estándar e           |&lt;--+        
      invocan a la función          interrupt_dispatcher()
      interrupt_dispatcher()             ^
                                         |    
                           +-------------+                              
IDT (idt.c)                |                        
    +------------------------------------------------------------------------+
    | isr0 | isr1 | ... | isrN  | isr31 | ... | isr47 | isr48 | ... | isr255 |
    +------------------------------------------------------------------------+
                            ^
                            |
     Excepción N (0-31) ----+</pre><dl class="section user"><dt>Instalar y Desinstalar Manejadores de Excepción</dt><dd></dd></dl>
<p>Para instalar un nuevo manejador de excepción, se debe invocar a la función install_exception_handler(() definida en el archivo <a class="el" href="../../d4/d43/exception_8c.html" title="Este archivo implementa las primitivas necesarias para el manejo de excepciones en la arquitectura IA...">exception.c</a>. Esta función recibe como parámetro el número de excepción, y el apuntador a la rutina que manejará la excepción. Este apuntador se almacena en la posición correspondiente en el arreglo (la tabla) <a class="el" href="../../d4/d43/exception_8c.html#a3ec3c1e26fba0c6c7090e0d70b805459">exception_handlers</a>.</p>
<p>Para desinstalar un manejador de excepción, se debe especificar el número de excepción. Esta función elimina el apuntador correspondiente en el arreglo (la tabla) <a class="el" href="../../d4/d43/exception_8c.html#a3ec3c1e26fba0c6c7090e0d70b805459">exception_handlers</a>.</p>
<h1><a class="anchor" id="irq_management"></a>
Gestión de Solicitudes de Interrupción - IRQ</h1>
<p>Cuando un dispositivo de Entrada / Salida requiere atención, lanza una Solicitud de Interrupción (Interrupt Request - IRQ). Estas IRQ son recibidas por un dispositivo llamado el PIC PIC (Programmable Interrupt Controller). El trabajo del PIC consiste en recibir y priorizar las IRQ recibidas, y enviar una señal de interrupción a la CPU.</p>
<p>En la arquitectura IA-32 el sistema cuenta con dos controladores PIC, uno llamado "Maestro" y otro "Esclavo", que se encuentra conectado en cascada al PIC Maestro. Cada PIC puede atender 8 líneas de IRQ, por lo tanto se pueden atender hasta 16 solicitudes.</p>
<p>Al arranque del sistema, las líneas de interrupción IRQ0 a IRQ 5 se encuentran mapeadas a las interrupciones numero 0x8 a 0xF. Las líneas de interrupción IRQ8 a IRQ 15 se encuentran mapeadas a las interrupciones 0x70 a 0x77.</p>
<dl class="section user"><dt>Lista de Solicitudes de Interrupción</dt><dd></dd></dl>
<p>La lista de IRQ es la siguiente:</p>
<pre class="fragment">                Número de 
    IRQ        Interrupción   Descripción
    ----      -------------   ---------------------------------------
    IRQ0         0x08         Timer 
    IRQ1         0x09         Teclado 
    IRQ2         0x0A         Cascade para el PIC esclavo 
    IRQ3         0x0B         Puerto serial 2 
    IRQ4         0x0C         Puerto serial 1
    IRQ5         0x0D         AT: Puerto paralelo2  PS/2 : reservado 
    IRQ6         0x0E         Diskette 
    IRQ7         0x0F         Puerto paralelo 1 
    IRQ8/IRQ0    0x70         Reloj de tiempo real del CMOS 
    IRQ9/IRQ1    0x71         Refresco vertical de CGA 
    IRQ10/IRQ2   0x72         Reservado 
    IRQ11/IRQ3   0x73         Reservado 
    IRQ12/IRQ4   0x74         AT: reservado. PS/2: disp. auxiliar 
    IRQ13/IRQ5   0x75         FPU (Unidad de Punto Flotante) 
    IRQ14/IRQ6   0x76         Controlador de disco duro 
    IRQ15/IRQ7   0x77         Reservado</pre><p>Al observar la tabla anterior, se hace evidente que existe un problema: las interrupciones 0x8 a 0x0F también son utilizadas para las excepciones de la arquitectura IA-32, ya que éstas siempre ocupan las interrupciones 0-31.</p>
<p>Por esta razón, es necesario reprogramar el PIC para que las interrupciones de entrada/salida se mapeen después de las excepciones de IA-32, es decir desde la interrupción numero 32 en adelante. A la IRQ 0 (Timer) le corresponderá la interrupción número 32, y asi sucesivamente.</p>
<p>A continuación se presenta el proceso, que se implementa en la función <a class="el" href="../../dd/de7/irq_8c.html#a60f49e6b52a3b02f389dff64c8155be4" title="Función que se encarga de re-mapear las IRQ 0x8 a 0xF.">irq_remap()</a> del archivo <a class="el" href="../../dd/de7/irq_8c.html" title="Contiene la implementacion de las rutinas necesarias para manejar las solicitudes de interrupcion (IR...">irq.c</a>. Esta función es invocada por <a class="el" href="../../d2/de7/irq_8h.html#a968e852c362480d5ba8d4192e0854af2" title="Esta rutina se encarga de crear las entradas en la IDT para las interrupciones que se desean manejar...">setup_irq()</a> en el momento de configurar la IRQ.</p>
<pre class="fragment">   /* Initialization Command Word 1 - ICW1
 Esta es la palabra primaria para inicializar el PIC.
 Para inicializar el PIC se requiere que los bits 0 y 4 de ICW1 esten en
 1 y los demas en 0. Esto significa que el valor de ICW1 es 0x11.
 ICW1 debe ser escrita en el  registro de comandos del PIC maestro
 (dirección de e/s 0x20). Si existe un PIC esclavo, ICW1 se debe enviar
 tambien su registro de comandos del PIC esclavo (0xA0)
 */

 outb(MASTER_PIC_COMMAND_PORT, 0x11);
 outb(SLAVE_PIC_COMMAND_PORT, 0x11);

 /* Initialization Command Word 2 - ICW2
 Esta palabra permite definir la dirección base (inicial) en la tabla de
 descriptores de interrupcion que el PIC va a utilizar.

 Debido a que las primeras 32 entradas estan reservadas para las
 excepciones en la arquitectura IA-32, ICW2 debe contener un valor mayor o
 igual a 32 (0x20). Los valores  de ICW2 representan el numero de IRQ
 base que manejara el PIC

 Al utilizar los PIC en cascada, se debe enviar ICW2 a los dos
 controladores en su registro de datos (0x21 y 0xA1 para maestro y
 esclavo respectivamente), indicando la dirección en la IDT que va a ser
 utilizada por cada uno de ellos.

 Las primeras 8 IRQ van a ser manejadas por el PIC maestro y se mapearan
 a partir del numero 32 (0x20). Las siguientes 8 interrupciones las manejara
 el PIC esclavo, y se mapearan a partir de la interrupcion 40 (0x28).
 */

 outb(MASTER_PIC_DATA_PORT, IDT_IRQ_OFFSET);
 outb(SLAVE_PIC_DATA_PORT, IDT_IRQ_OFFSET + 8);

 /* Initialization Control Word 3 - ICW3
 Esta palabra permite definir cuales lineas de IRQ van a ser compartidas
 por los PIC maestro y esclavo. Al igual que ICW2, ICW3 tambien se
 escribe en los  registros de datos de los PIC (0x21 y 0xA1 para el PIC
 maestro y esclavo,respectivamente).

 Dado que en la arquitectura Intel el PIC maestro se conecta con el PIC
 esclavo por medio de la linea IRQ 2, el valor de ICW3 debe ser 00000100
 (0x04), que define el bit 3 (correspondiente a la linea IRQ2) en 1.

 Para el PIC esclavo, el numero de la linea se debe representar en
 notacion binaria. Por lo tanto, 000 corresponde a la linea de IRQ 0,
 001 corresponde a la linea de IRQ 1, 010 corresponde a la linea de
 IRQ 2, y asi sucesivamente.
 Debido a que se va a utilizar la linea de IRQ 2, el valor de ICW3
 para el PIC esclavo debe ser 00000010, (0x02).
 */

 outb(MASTER_PIC_DATA_PORT, 0x04);
 outb(SLAVE_PIC_DATA_PORT, 0x02);

 /* Initialization Control Word 4 - ICW4
 Para ICW4 solo es necesario establecer su bit 0 (x86 mode) y escribirla
 en los registros de datos del PIC maestro y esclavo (0x21 y 0xA1).
 El valor de ICW4 debe ser entonces 00000001, es decir, 0x01.
 */
 outb(MASTER_PIC_DATA_PORT, 0x01);
 outb(SLAVE_PIC_DATA_PORT, 0x01);

 /* Se han mapeado las IRQ!.
  * Las IRQ 0-7 seran atendidas por el PIC maestro, y las IRQ 8-15
  * por el PIC esclavo. Las IRQ0-15 estaran mapeadas en la IDT a partir
  * de la entrada 32 hasta la 47.*/
</pre><dl class="section user"><dt>Rutina para la gestión de las IRQ</dt><dd></dd></dl>
<p>Luego de re-configurar el PIC para que las 16 IRQ generen las interrupciones 32 a 47, la función <a class="el" href="../../d2/de7/irq_8h.html#a968e852c362480d5ba8d4192e0854af2" title="Esta rutina se encarga de crear las entradas en la IDT para las interrupciones que se desean manejar...">setup_irq()</a> configura estas entradas en la tabla <a class="el" href="../../d5/d05/idt_8c.html#adc7a0623aadf5f38415f8847cb297c86">interrupt_handlers</a> para que apunten a la función <a class="el" href="../../dd/de7/irq_8c.html#af1056c4d9493edebb758d2143fbc049b" title="Esta rutina recibe el control de la rutina de manejo de interrupcion y canaliza esta solicitud a la r...">irq_dispatcher()</a> definida en el archivo <a class="el" href="../../dd/de7/irq_8c.html" title="Contiene la implementacion de las rutinas necesarias para manejar las solicitudes de interrupcion (IR...">irq.c</a>. Esta rutina, similar a <a class="el" href="../../d4/d43/exception_8c.html#acccb5e3de60f72eacd7efb046ec6c267" title="Esta rutina recibe el control de la interrupt_dispatcher. Su trabajo consiste en determinar el vector...">exception_dispatcher()</a> permite centralizar el manejo de las IRQ.</p>
<dl class="section user"><dt>Instalar y Desinstalar Manejadores de IRQ</dt><dd></dd></dl>
<p>Para instalar un nuevo manejador de IRQ, se debe invocar a la función <a class="el" href="../../d2/de7/irq_8h.html#a470fad09cd8ee471a1300ec395666eef" title="Esta rutina permite definir un nuevo manejador de IRQ.">install_irq_handler()</a> definida en el archivo <a class="el" href="../../dd/de7/irq_8c.html" title="Contiene la implementacion de las rutinas necesarias para manejar las solicitudes de interrupcion (IR...">irq.c</a>. Esta función recibe como parámetro el número de la IRQ (0 a 15), y el apuntador a la rutina que manejará la IRQ. Este apuntador se almacena en la posición correspondiente en el arreglo (la tabla) <a class="el" href="../../dd/de7/irq_8c.html#a8b1cf32dc47384315810964d89e6f246">irq_handlers</a>.</p>
<p>Para desinstalar un manejador de IRQ, se debe especificar el número de IRQ. Esta función elimina el apuntador correspondiente en el arreglo (la tabla) <a class="el" href="../../dd/de7/irq_8c.html#a8b1cf32dc47384315810964d89e6f246">irq_handlers</a>.</p>
<dl class="section user"><dt>Proceso de gestión de una IRQ</dt><dd></dd></dl>
<p>A continuación se describe el proceso para gestionar una excepción.</p>
<ol type="1">
<li>Cuando ocurre una IRQ N (interrupción 32 a 47), se ejecuta la rutina isrN ( 32 &lt;= N &lt;= 74) correspondiente (configurada en <a class="el" href="../../d4/d35/idt_8h.html#a9782031a7d6cb759022b58789382f5eb" title="Esta rutina se encarga de cargar la IDT.">setup_idt()</a>).</li>
<li>La rutina isrN crea el marco de pila en el cual almacena el estado del procesador, guarda el apuntador actual a la pila (current_ss y current_esp) e invoca a la función <a class="el" href="../../d5/d05/idt_8c.html#a491194ab27dc6f0939626c92cf4b376e" title="Esta rutina recibe el control de la Rutina de Servicio de Interrupción (ISR) isr0, isr1.. etc. correspondiente. Su trabajo consiste en determinar el vector de interrupción a partir del estado que recibe como parametro, y de invocar la rutina de manejo de interrupción adecuada, si existe.">interrupt_dispatcher()</a>.</li>
<li>La función <a class="el" href="../../d5/d05/idt_8c.html#a491194ab27dc6f0939626c92cf4b376e" title="Esta rutina recibe el control de la Rutina de Servicio de Interrupción (ISR) isr0, isr1.. etc. correspondiente. Su trabajo consiste en determinar el vector de interrupción a partir del estado que recibe como parametro, y de invocar la rutina de manejo de interrupción adecuada, si existe.">interrupt_dispatcher()</a> busca dentro de la tabla <a class="el" href="../../d5/d05/idt_8c.html#adc7a0623aadf5f38415f8847cb297c86">interrupt_handlers</a> el apuntador a la rutina de manejo de interrupción. Debido a que la función <a class="el" href="../../d2/de7/irq_8h.html#a968e852c362480d5ba8d4192e0854af2" title="Esta rutina se encarga de crear las entradas en la IDT para las interrupciones que se desean manejar...">setup_irq()</a> ha configurado las entradas 32 a 47 para que apunten a la función <a class="el" href="../../dd/de7/irq_8c.html#af1056c4d9493edebb758d2143fbc049b" title="Esta rutina recibe el control de la rutina de manejo de interrupcion y canaliza esta solicitud a la r...">irq_dispatcher()</a> (<a class="el" href="../../dd/de7/irq_8c.html" title="Contiene la implementacion de las rutinas necesarias para manejar las solicitudes de interrupcion (IR...">irq.c</a>), se invoca esta función.</li>
<li>La función <a class="el" href="../../dd/de7/irq_8c.html#af1056c4d9493edebb758d2143fbc049b" title="Esta rutina recibe el control de la rutina de manejo de interrupcion y canaliza esta solicitud a la r...">irq_dispatcher()</a> busca dentro de la tabla <a class="el" href="../../dd/de7/irq_8c.html#a8b1cf32dc47384315810964d89e6f246">irq_handlers</a> el apuntador a la función que manejará la IRQ correspondiente (que se configura con la función <a class="el" href="../../d2/de7/irq_8h.html#a470fad09cd8ee471a1300ec395666eef" title="Esta rutina permite definir un nuevo manejador de IRQ.">install_irq_handler()</a> en el archivo <a class="el" href="../../dd/de7/irq_8c.html" title="Contiene la implementacion de las rutinas necesarias para manejar las solicitudes de interrupcion (IR...">irq.c</a>). Si existe un manejador de IRQ, se invoca. En caso contrario, la función <a class="el" href="../../dd/de7/irq_8c.html#af1056c4d9493edebb758d2143fbc049b" title="Esta rutina recibe el control de la rutina de manejo de interrupcion y canaliza esta solicitud a la r...">irq_dispatcher()</a> retorna.</li>
<li>Cuando la rutina de manejo de IRQ termina, retorna el control a la función <a class="el" href="../../dd/de7/irq_8c.html#af1056c4d9493edebb758d2143fbc049b" title="Esta rutina recibe el control de la rutina de manejo de interrupcion y canaliza esta solicitud a la r...">irq_dispatcher()</a>. Esta a su vez retorna el control a <a class="el" href="../../d5/d05/idt_8c.html#a491194ab27dc6f0939626c92cf4b376e" title="Esta rutina recibe el control de la Rutina de Servicio de Interrupción (ISR) isr0, isr1.. etc. correspondiente. Su trabajo consiste en determinar el vector de interrupción a partir del estado que recibe como parametro, y de invocar la rutina de manejo de interrupción adecuada, si existe.">interrupt_dispatcher()</a>, la cual retorna a la función isrN definida en <a class="el" href="../../d5/df9/isr_8_s.html" title="Contiene la definicion y la implementacion de las rutinas de servicio de interrupcion para las 255 in...">isr.S</a>.</li>
<li>Luego de recibir el control de <a class="el" href="../../d5/d05/idt_8c.html#a491194ab27dc6f0939626c92cf4b376e" title="Esta rutina recibe el control de la Rutina de Servicio de Interrupción (ISR) isr0, isr1.. etc. correspondiente. Su trabajo consiste en determinar el vector de interrupción a partir del estado que recibe como parametro, y de invocar la rutina de manejo de interrupción adecuada, si existe.">interrupt_dispatcher()</a>, la rutina isrN invoca a la función return_from_interrupt() definida en <a class="el" href="../../d5/df9/isr_8_s.html" title="Contiene la definicion y la implementacion de las rutinas de servicio de interrupcion para las 255 in...">isr.S</a>. Esta función recupera el estado del procesador y retorna al sitio en el cual el procesador fue interrumpido.</li>
</ol>
<pre class="fragment">             Esquema general del Manejo de IRQ
             
             
 La función irq_dispatcher()                      +-----------------------+
   busca dentro del arreglo                       | Rutina de manejo de   |
   irq_handlers el apuntador              +------&gt;| la IRQ I (que         |
   a la rutina de manejo de IRQ           |       | corresponde a la      |
   (handler) N.                           |       | interrupción 32 + I)  |
                                          |   +---+-----------------------+
                                          |   |               
irq_handlers (irq.c)                      |   v
   +--------------------------------------------------------------------------+
   | * handler 0 | * handler 1 | ... | *handler I | ...  | ...  | handler 15  |
   +--------------------------------------------------------------------------+
                                           ^    | 
                                           | |
    A la interrupción N ( 32 &lt;= N &lt;= 47)   I    |
    le corresponde la IRQ I = N - 32       |    v
                                           +-----------------+          
                                                             |
   La función interrupt_dispatcher()              +-----------------------+
   busca dentro del arreglo                       | Las entradas 32 a 47  |
   interrupt_handlers                     +------&gt;| de interrupt_handlers |
   el apuntador a la rutina de            |       | apuntan a la rutina   |
   manejo de interrupción                 |       | irq_dispatcher        |
   (handler) N.                           |   +---+-----------------------+
                                          |   |               
interrupt_handlers (idt.c)                |   v
   +--------------------------------------------------------------------------+
   | * handler 0 | * handler 1 | ... | *handler N | ...  | ...  | handler 255 |
   +--------------------------------------------------------------------------+ 
                                         |   |  La función de manejo de 
      Todas las ISR establecen un        |   |  interrupción retorna el control
      marco de pila estándar e           |&lt;--+        
      invocan a la función          interrupt_dispatcher()
      interrupt_dispatcher()             ^
                                         |    
                           +-------------+                              
IDT (idt.c)                |                        
    +------------------------------------------------------------------------+
    | isr0 | isr1 | ... | isrN  | isr31 | ... | isr47 | isr48 | ... | isr255 |
    +------------------------------------------------------------------------+
                            ^
                            |
     Excepción N (0-31) ----+</pre><dl class="section see"><dt>Ver también</dt><dd><a href="http://www.gnu.org/software/grub/manual/multiboot/multiboot.html">http://www.gnu.org/software/grub/manual/multiboot/multiboot.html</a> Especificación Multiboot </dd>
<dd>
<a href="http://www.skyfree.org/linux/references/ELF_Format.pdf">http://www.skyfree.org/linux/references/ELF_Format.pdf</a> Especificación ELF </dd>
<dd>
<a href="http://www.gnu.org/software/grub/">http://www.gnu.org/software/grub/</a> Página oficial de GRUB (Enlace externo) </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generado por &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
