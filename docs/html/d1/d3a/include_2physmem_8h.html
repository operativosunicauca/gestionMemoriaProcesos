<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Proyecto 10 - Gestión de Memoria Física: Referencia del Archivo include/physmem.h</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Proyecto 10 - Gestión de Memoria Física
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">Aprendiendo Sistemas Operativos</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Buscar');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Página&#160;principal</span></a></li>
      <li><a href="../../pages.html"><span>Páginas&#160;relacionadas</span></a></li>
      <li><a href="../../modules.html"><span>Módulos</span></a></li>
      <li><a href="../../annotated.html"><span>Estructuras&#160;de&#160;Datos</span></a></li>
      <li class="current"><a href="../../files.html"><span>Archivos</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Buscar" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>Lista&#160;de&#160;archivos</span></a></li>
      <li><a href="../../globals.html"><span>Globales</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Todo</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Estructuras de Datos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Archivos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Funciones</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>&apos;typedefs&apos;</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>&apos;defines&apos;</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Grupos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Páginas</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Estructuras de datos</a> &#124;
<a href="#define-members">'defines'</a> &#124;
<a href="#typedef-members">'typedefs'</a> &#124;
<a href="#func-members">Funciones</a>  </div>
  <div class="headertitle">
<div class="title">Referencia del Archivo physmem.h<div class="ingroups"><a class="el" href="../../d9/d1c/group__kernel__code.html">Código del Kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Contiene las definiciones relacionadas con las gestión de memoria del kernel.  
<a href="#details">Más...</a></p>

<p><a href="../../d1/d3a/include_2physmem_8h_source.html">Ir al código fuente de este archivo.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Estructuras de datos</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/da1/structnode.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">En esta parte creamos una estructura de datos node. Que va a representar cada nodo de nuestra lista enlazada. Tiene un apuntador previous y un apuntador nex para ue sea doblemente enlazada. Tiene un estado (state) que va a representar L o U (Libre o Usado). Además tiene un start que me indica en que parte de la memoria inicia esta región ya sea libre u ocupada y tiene un lenght que me indica el tamaño de esta región que representa el nodo.  <a href="../../d5/da1/structnode.html#details">Más...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creamos una estructura de datos <a class="el" href="../../d7/d99/structmemory__list.html" title="Creamos una estructura de datos memory_list que será la lista enlazada con la que haremos el la gesti...">memory_list</a> que será la lista enlazada con la que haremos el la gestión de la memoria. Tiene dos nodos, la cabeza (head) y la cola (tail) con los que vamos a referenciar todos los nodos que pertenecen a la lista. También tiene un contador (count) que va a llevar el número de nodos que componen la lista.  <a href="../../d7/d99/structmemory__list.html#details">Más...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
'defines'</h2></td></tr>
<tr class="memitem:abd03c49c90122f4dc22745979c5db642"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#abd03c49c90122f4dc22745979c5db642">MEMORY_UNIT_SIZE</a>&#160;&#160;&#160;4096</td></tr>
<tr class="memdesc:abd03c49c90122f4dc22745979c5db642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tamaño de la unidad de asignación de memoria.  <a href="#abd03c49c90122f4dc22745979c5db642">Más...</a><br/></td></tr>
<tr class="separator:abd03c49c90122f4dc22745979c5db642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fde4dbd3bbdb9a44b67a032f162bb6e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#a1fde4dbd3bbdb9a44b67a032f162bb6e">MEMORY_UNITS</a>&#160;&#160;&#160;(<a class="el" href="../../d7/d4f/src_2physmem_8c.html#a3b7c9b85fabf9cce726d13c5974b4797">memory_length</a> / <a class="el" href="../../d1/d3a/include_2physmem_8h.html#abd03c49c90122f4dc22745979c5db642">MEMORY_UNIT_SIZE</a>)</td></tr>
<tr class="memdesc:a1fde4dbd3bbdb9a44b67a032f162bb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Número de unidades en la memoria disponible.  <a href="#a1fde4dbd3bbdb9a44b67a032f162bb6e">Más...</a><br/></td></tr>
<tr class="separator:a1fde4dbd3bbdb9a44b67a032f162bb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af654f7f40cf60edfba570a6411640cd4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#af654f7f40cf60edfba570a6411640cd4">KERNEL_HEAP_SIZE</a>&#160;&#160;&#160;0x100000</td></tr>
<tr class="memdesc:af654f7f40cf60edfba570a6411640cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tamanio en bytes del HEAP del kernel, 1 MB.  <a href="#af654f7f40cf60edfba570a6411640cd4">Más...</a><br/></td></tr>
<tr class="separator:af654f7f40cf60edfba570a6411640cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
'typedefs'</h2></td></tr>
<tr class="memitem:af4aeda155dbe167f1c1cf38cb65bf324"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="../../d5/da1/structnode.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#af4aeda155dbe167f1c1cf38cb65bf324">node</a></td></tr>
<tr class="memdesc:af4aeda155dbe167f1c1cf38cb65bf324"><td class="mdescLeft">&#160;</td><td class="mdescRight">En esta parte creamos una estructura de datos node. Que va a representar cada nodo de nuestra lista enlazada. Tiene un apuntador previous y un apuntador nex para ue sea doblemente enlazada. Tiene un estado (state) que va a representar L o U (Libre o Usado). Además tiene un start que me indica en que parte de la memoria inicia esta región ya sea libre u ocupada y tiene un lenght que me indica el tamaño de esta región que representa el nodo.  <a href="#af4aeda155dbe167f1c1cf38cb65bf324">Más...</a><br/></td></tr>
<tr class="separator:af4aeda155dbe167f1c1cf38cb65bf324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed645bbf6d53327dddcdee4dcc0f427"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d5/da1/structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#aeed645bbf6d53327dddcdee4dcc0f427">node_iterator</a></td></tr>
<tr class="separator:aeed645bbf6d53327dddcdee4dcc0f427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2958b1a91d28588d354366c7c8b6ca0"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#ae2958b1a91d28588d354366c7c8b6ca0">memory_list</a></td></tr>
<tr class="memdesc:ae2958b1a91d28588d354366c7c8b6ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creamos una estructura de datos <a class="el" href="../../d7/d99/structmemory__list.html" title="Creamos una estructura de datos memory_list que será la lista enlazada con la que haremos el la gesti...">memory_list</a> que será la lista enlazada con la que haremos el la gestión de la memoria. Tiene dos nodos, la cabeza (head) y la cola (tail) con los que vamos a referenciar todos los nodos que pertenecen a la lista. También tiene un contador (count) que va a llevar el número de nodos que componen la lista.  <a href="#ae2958b1a91d28588d354366c7c8b6ca0">Más...</a><br/></td></tr>
<tr class="separator:ae2958b1a91d28588d354366c7c8b6ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funciones</h2></td></tr>
<tr class="memitem:af711637f21461ed6252595238aa52983"><td class="memItemLeft" align="right" valign="top">static __inline__ unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#af711637f21461ed6252595238aa52983">round_down_to_memory_unit</a> (addr)</td></tr>
<tr class="memdesc:af711637f21461ed6252595238aa52983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Función que redondea una dirección de memoria a la dirección más cercana por debajo que sea múltiplo de MEMORY_UNIT_SIZE.  <a href="#af711637f21461ed6252595238aa52983">Más...</a><br/></td></tr>
<tr class="separator:af711637f21461ed6252595238aa52983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bb1a508cbed0aa2b632fcbb089c597"><td class="memItemLeft" align="right" valign="top">static __inline__ unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#a04bb1a508cbed0aa2b632fcbb089c597">round_up_to_memory_unit</a> (addr)</td></tr>
<tr class="memdesc:a04bb1a508cbed0aa2b632fcbb089c597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Función que redondea una dirección de memoria a la dirección más cercana por encima que sea múltiplo de MEMORY_UNIT_SIZE.  <a href="#a04bb1a508cbed0aa2b632fcbb089c597">Más...</a><br/></td></tr>
<tr class="separator:a04bb1a508cbed0aa2b632fcbb089c597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6d6d860a3dd67eb762ee84a2a8368c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#a6d6d6d860a3dd67eb762ee84a2a8368c">kmalloc</a> (unsigned int size)</td></tr>
<tr class="memdesc:a6d6d6d860a3dd67eb762ee84a2a8368c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solicita asignacion de memoria dentro del heap.  <a href="#a6d6d6d860a3dd67eb762ee84a2a8368c">Más...</a><br/></td></tr>
<tr class="separator:a6d6d6d860a3dd67eb762ee84a2a8368c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069f85a5001d71bc44d8be6532a4e432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#a069f85a5001d71bc44d8be6532a4e432">kfree</a> (void *ptr)</td></tr>
<tr class="memdesc:a069f85a5001d71bc44d8be6532a4e432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solicita liberar una region de memoria dentro del heap.  <a href="#a069f85a5001d71bc44d8be6532a4e432">Más...</a><br/></td></tr>
<tr class="separator:a069f85a5001d71bc44d8be6532a4e432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8950a0a5d1ef2c64d6d99cbb29222803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#a8950a0a5d1ef2c64d6d99cbb29222803">setup_memory</a> (void)</td></tr>
<tr class="memdesc:a8950a0a5d1ef2c64d6d99cbb29222803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta rutina inicializa el mapa de bits de memoria, a partir de la informacion obtenida del GRUB.  <a href="#a8950a0a5d1ef2c64d6d99cbb29222803">Más...</a><br/></td></tr>
<tr class="separator:a8950a0a5d1ef2c64d6d99cbb29222803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe29acb95fb642b1d6639f7d3593d201"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#afe29acb95fb642b1d6639f7d3593d201">allocate_unit</a> ()</td></tr>
<tr class="memdesc:afe29acb95fb642b1d6639f7d3593d201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Busca una unidad libre dentro del mapa de bits de memoria.  <a href="#afe29acb95fb642b1d6639f7d3593d201">Más...</a><br/></td></tr>
<tr class="separator:afe29acb95fb642b1d6639f7d3593d201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa6e121afc225468bc3b136428552e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#aefa6e121afc225468bc3b136428552e6">allocate_unit_region</a> (unsigned int length)</td></tr>
<tr class="memdesc:aefa6e121afc225468bc3b136428552e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Busca una región de memoria contigua libre dentro del mapa de bits de memoria.  <a href="#aefa6e121afc225468bc3b136428552e6">Más...</a><br/></td></tr>
<tr class="separator:aefa6e121afc225468bc3b136428552e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37fdd7c43e1092a00fe53d8eca2a4f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#ad37fdd7c43e1092a00fe53d8eca2a4f9">free_region</a> (unsigned int start_addr, unsigned int length)</td></tr>
<tr class="memdesc:ad37fdd7c43e1092a00fe53d8eca2a4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permite liberar una región de memoria.  <a href="#ad37fdd7c43e1092a00fe53d8eca2a4f9">Más...</a><br/></td></tr>
<tr class="separator:ad37fdd7c43e1092a00fe53d8eca2a4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0ffbc2b9c56d76912e39c2008bab66"><td class="memItemLeft" align="right" valign="top">static __inline__ <a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#aec0ffbc2b9c56d76912e39c2008bab66">create_memory_list</a> ()</td></tr>
<tr class="memdesc:aec0ffbc2b9c56d76912e39c2008bab66"><td class="mdescLeft">&#160;</td><td class="mdescRight">construye una nueva lista.  <a href="#aec0ffbc2b9c56d76912e39c2008bab66">Más...</a><br/></td></tr>
<tr class="separator:aec0ffbc2b9c56d76912e39c2008bab66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6a59fafed2782072f6d7f790e2a61d"><td class="memItemLeft" align="right" valign="top">static __inline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#aab6a59fafed2782072f6d7f790e2a61d">inicializar_memoria_disponible</a> (<a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *, unsigned int, unsigned int)</td></tr>
<tr class="memdesc:aab6a59fafed2782072f6d7f790e2a61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Agrega los nodos que representan la memoria disponible en la lista.  <a href="#aab6a59fafed2782072f6d7f790e2a61d">Más...</a><br/></td></tr>
<tr class="separator:aab6a59fafed2782072f6d7f790e2a61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac541ca4737fd15ac73fc4d55907f36a5"><td class="memItemLeft" align="right" valign="top">static __inline__ <a class="el" href="../../d5/da1/structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#ac541ca4737fd15ac73fc4d55907f36a5">create_node</a> (char, unsigned int, unsigned int)</td></tr>
<tr class="memdesc:ac541ca4737fd15ac73fc4d55907f36a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea un nuevo nodo.  <a href="#ac541ca4737fd15ac73fc4d55907f36a5">Más...</a><br/></td></tr>
<tr class="separator:ac541ca4737fd15ac73fc4d55907f36a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21baf943b2f9352509a531b6206fbd9f"><td class="memItemLeft" align="right" valign="top">static __inline__ void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#a21baf943b2f9352509a531b6206fbd9f">push_front</a> (<a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *, <a class="el" href="../../d5/da1/structnode.html">node</a> *)</td></tr>
<tr class="memdesc:a21baf943b2f9352509a531b6206fbd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Agrega un nodo en el frente de la lista.  <a href="#a21baf943b2f9352509a531b6206fbd9f">Más...</a><br/></td></tr>
<tr class="separator:a21baf943b2f9352509a531b6206fbd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251f2258231eefe0ad419b73d0fbbba2"><td class="memItemLeft" align="right" valign="top">static __inline__ void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#a251f2258231eefe0ad419b73d0fbbba2">push_back</a> (<a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *, <a class="el" href="../../d5/da1/structnode.html">node</a> *)</td></tr>
<tr class="memdesc:a251f2258231eefe0ad419b73d0fbbba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Agrega un nodo al final de la lista.  <a href="#a251f2258231eefe0ad419b73d0fbbba2">Más...</a><br/></td></tr>
<tr class="separator:a251f2258231eefe0ad419b73d0fbbba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaccb21f57209d357608ab633a27e8bb"><td class="memItemLeft" align="right" valign="top">static __inline__ void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#afaccb21f57209d357608ab633a27e8bb">pop_front</a> (<a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *)</td></tr>
<tr class="memdesc:afaccb21f57209d357608ab633a27e8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quita el nodo que se encuentra al inicio de la lista.  <a href="#afaccb21f57209d357608ab633a27e8bb">Más...</a><br/></td></tr>
<tr class="separator:afaccb21f57209d357608ab633a27e8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9ed58c02514095b8afe1320b293fbb"><td class="memItemLeft" align="right" valign="top">static __inline__ void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#a7f9ed58c02514095b8afe1320b293fbb">pop_back</a> (<a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *)</td></tr>
<tr class="memdesc:a7f9ed58c02514095b8afe1320b293fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quita el nodo que se encuenta el final de la lista.  <a href="#a7f9ed58c02514095b8afe1320b293fbb">Más...</a><br/></td></tr>
<tr class="separator:a7f9ed58c02514095b8afe1320b293fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2d8be1a11543ee8d99cc03bf77aaba"><td class="memItemLeft" align="right" valign="top">static __inline__ <a class="el" href="../../d1/d3a/include_2physmem_8h.html#aeed645bbf6d53327dddcdee4dcc0f427">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#a6f2d8be1a11543ee8d99cc03bf77aaba">head</a> (<a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *)</td></tr>
<tr class="memdesc:a6f2d8be1a11543ee8d99cc03bf77aaba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Con esta función obtengo el nodo del inicio de la lista.  <a href="#a6f2d8be1a11543ee8d99cc03bf77aaba">Más...</a><br/></td></tr>
<tr class="separator:a6f2d8be1a11543ee8d99cc03bf77aaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b96c57dcf1283789c7031f319f7715"><td class="memItemLeft" align="right" valign="top">static __inline__ <a class="el" href="../../d1/d3a/include_2physmem_8h.html#aeed645bbf6d53327dddcdee4dcc0f427">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#ac2b96c57dcf1283789c7031f319f7715">next</a> (<a class="el" href="../../d1/d3a/include_2physmem_8h.html#aeed645bbf6d53327dddcdee4dcc0f427">node_iterator</a>)</td></tr>
<tr class="memdesc:ac2b96c57dcf1283789c7031f319f7715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Con esta función obtengo el siguiente a un nodo dado.  <a href="#ac2b96c57dcf1283789c7031f319f7715">Más...</a><br/></td></tr>
<tr class="separator:ac2b96c57dcf1283789c7031f319f7715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdef7a1fd863a6d3770c1268cb06add3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#acdef7a1fd863a6d3770c1268cb06add3">main</a> ()</td></tr>
<tr class="memdesc:acdef7a1fd863a6d3770c1268cb06add3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaración de la función main implementada en physmem.c.  <a href="#acdef7a1fd863a6d3770c1268cb06add3">Más...</a><br/></td></tr>
<tr class="separator:acdef7a1fd863a6d3770c1268cb06add3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0764342c13c1a182cc07d732f3e5738c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#a0764342c13c1a182cc07d732f3e5738c">free_unit</a> (unsigned int)</td></tr>
<tr class="memdesc:a0764342c13c1a182cc07d732f3e5738c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permite liberar una unidad de memoria.  <a href="#a0764342c13c1a182cc07d732f3e5738c">Más...</a><br/></td></tr>
<tr class="separator:a0764342c13c1a182cc07d732f3e5738c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976cadc7662d76d7023129c66e3a2fd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#a976cadc7662d76d7023129c66e3a2fd6">asignar_unidades</a> (<a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *, unsigned int)</td></tr>
<tr class="memdesc:a976cadc7662d76d7023129c66e3a2fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaración de la función asignar_unidades implementada en physmem.c.  <a href="#a976cadc7662d76d7023129c66e3a2fd6">Más...</a><br/></td></tr>
<tr class="separator:a976cadc7662d76d7023129c66e3a2fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37faf0202d020fc6220be7d802cb6f04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#a37faf0202d020fc6220be7d802cb6f04">unirNodosLibres</a> (<a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *, <a class="el" href="../../d5/da1/structnode.html">node</a> *)</td></tr>
<tr class="memdesc:a37faf0202d020fc6220be7d802cb6f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaración de la función unirNodosLibres implementada en physmem.c.  <a href="#a37faf0202d020fc6220be7d802cb6f04">Más...</a><br/></td></tr>
<tr class="separator:a37faf0202d020fc6220be7d802cb6f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descripción detallada</h2>
<div class="textblock"><p>Contiene las definiciones relacionadas con las gestión de memoria del kernel. </p>
<dl class="section author"><dt>Autor</dt><dd>Erwin Meza <a href="#" onclick="location.href='mai'+'lto:'+'eme'+'za'+'v@g'+'ma'+'il.'+'co'+'m'; return false;">emeza<span style="display: none;">.nosp@m.</span>v@gm<span style="display: none;">.nosp@m.</span>ail.c<span style="display: none;">.nosp@m.</span>om</a> </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>GNU Public License. </dd></dl>

<p>Definición en el archivo <a class="el" href="../../d1/d3a/include_2physmem_8h_source.html">physmem.h</a>.</p>
</div><h2 class="groupheader">Documentación de los 'defines'</h2>
<a class="anchor" id="af654f7f40cf60edfba570a6411640cd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KERNEL_HEAP_SIZE&#160;&#160;&#160;0x100000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tamanio en bytes del HEAP del kernel, 1 MB. </p>

<p>Definición en la línea <a class="el" href="../../d1/d3a/include_2physmem_8h_source.html#l00044">44</a> del archivo <a class="el" href="../../d1/d3a/include_2physmem_8h_source.html">physmem.h</a>.</p>

</div>
</div>
<a class="anchor" id="abd03c49c90122f4dc22745979c5db642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMORY_UNIT_SIZE&#160;&#160;&#160;4096</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tamaño de la unidad de asignación de memoria. </p>

<p>Definición en la línea <a class="el" href="../../d1/d3a/include_2physmem_8h_source.html#l00014">14</a> del archivo <a class="el" href="../../d1/d3a/include_2physmem_8h_source.html">physmem.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1fde4dbd3bbdb9a44b67a032f162bb6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMORY_UNITS&#160;&#160;&#160;(<a class="el" href="../../d7/d4f/src_2physmem_8c.html#a3b7c9b85fabf9cce726d13c5974b4797">memory_length</a> / <a class="el" href="../../d1/d3a/include_2physmem_8h.html#abd03c49c90122f4dc22745979c5db642">MEMORY_UNIT_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Número de unidades en la memoria disponible. </p>

<p>Definición en la línea <a class="el" href="../../d1/d3a/include_2physmem_8h_source.html#l00017">17</a> del archivo <a class="el" href="../../d1/d3a/include_2physmem_8h_source.html">physmem.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Documentación de los 'typedefs'</h2>
<a class="anchor" id="ae2958b1a91d28588d354366c7c8b6ca0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a>  <a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creamos una estructura de datos <a class="el" href="../../d7/d99/structmemory__list.html" title="Creamos una estructura de datos memory_list que será la lista enlazada con la que haremos el la gesti...">memory_list</a> que será la lista enlazada con la que haremos el la gestión de la memoria. Tiene dos nodos, la cabeza (head) y la cola (tail) con los que vamos a referenciar todos los nodos que pertenecen a la lista. También tiene un contador (count) que va a llevar el número de nodos que componen la lista. </p>

</div>
</div>
<a class="anchor" id="af4aeda155dbe167f1c1cf38cb65bf324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="../../d5/da1/structnode.html">node</a> <a class="el" href="../../d5/da1/structnode.html">node</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>En esta parte creamos una estructura de datos node. Que va a representar cada nodo de nuestra lista enlazada. Tiene un apuntador previous y un apuntador nex para ue sea doblemente enlazada. Tiene un estado (state) que va a representar L o U (Libre o Usado). Además tiene un start que me indica en que parte de la memoria inicia esta región ya sea libre u ocupada y tiene un lenght que me indica el tamaño de esta región que representa el nodo. </p>

</div>
</div>
<a class="anchor" id="aeed645bbf6d53327dddcdee4dcc0f427"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d5/da1/structnode.html">node</a>* <a class="el" href="../../d1/d3a/include_2physmem_8h.html#aeed645bbf6d53327dddcdee4dcc0f427">node_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definición en la línea <a class="el" href="../../d1/d3a/include_2physmem_8h_source.html#l00105">105</a> del archivo <a class="el" href="../../d1/d3a/include_2physmem_8h_source.html">physmem.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Documentación de las funciones</h2>
<a class="anchor" id="afe29acb95fb642b1d6639f7d3593d201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocate_unit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Busca una unidad libre dentro del mapa de bits de memoria. </p>
<dl class="section return"><dt>Devuelve</dt><dd>Dirección de inicio de la unidad en memoria.</dd>
<dd>
Direcciï¿½n de inicio de la unidad en memoria. </dd></dl>
<pre class="fragment">                  Define las unidades disponibles de memoria
</pre><p> que dispone</p>
<pre class="fragment">                  Define las unidades disponibles de memoria
</pre><p> que dispone </p>

<p>Definición en la línea <a class="el" href="../../de/d99/doc__bitmap_2physmem_8c_source.html#l00288">288</a> del archivo <a class="el" href="../../de/d99/doc__bitmap_2physmem_8c_source.html">physmem.c</a>.</p>

</div>
</div>
<a class="anchor" id="aefa6e121afc225468bc3b136428552e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocate_unit_region </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Busca una región de memoria contigua libre dentro del mapa de bits de memoria. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Tamaño de la región de memoria a asignar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Dirección de inicio de la región en memoria.</dd></dl>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Tamaño de la región de memoria a asignar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Dirección de inicio de la región en memoria.</dd></dl>
<p>El proceso que realiza esta funcion es, </p>
<pre class="fragment">  1.Verificar si no existen unidades libres, de ser asi, el valor de
    retorno es 0
  2.Luego si existen unidades libres, entonces, se inicia una iteracion
    en busqueda de una unidad de memoria disponible.
  3.De no existir una unidad libre dentro del mapa de bits, entonces
    devuelve 0; en caso de que si, devuelve la direccion de inicio
    de la region de memoria multiplicando las unidades libres
    de memoria por el tamaño de asignacin de una unidad de memoria.
</pre><p>Busca una región de memoria contigua libre dentro del mapa de bits de memoria.</p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Tamaï¿½o de la regiï¿½n de memoria a asignar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Direcciï¿½n de inicio de la regiï¿½n en memoria. </dd></dl>

<p>Definición en la línea <a class="el" href="../../de/d99/doc__bitmap_2physmem_8c_source.html#l00332">332</a> del archivo <a class="el" href="../../de/d99/doc__bitmap_2physmem_8c_source.html">physmem.c</a>.</p>

</div>
</div>
<a class="anchor" id="a976cadc7662d76d7023129c66e3a2fd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asignar_unidades </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *&#160;</td>
          <td class="paramname"><em>klist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nUnits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declaración de la función asignar_unidades implementada en physmem.c. </p>
<p>Declaración de la función asignar_unidades implementada en physmem.c.</p>
<p>Se recorre la lista con un apuntador que inicia en la cabecera y termina al final o donde se pueda asignar a la memoria.</p>
<p>Para esto se verifica si al nodo al que apunta se encuentra libre, si esto ocurre el tamaÃ±o del nodo deberÃ¡ corresponder a las unidades requeridas para reservar; y se cambia el estado del nodo a usado.</p>
<p>Por el contrario si el tamaÃ±o del nodo es mayor a las unidades requeridas, se nombra Ocupado y se enlaza a la lista.</p>
<p>Se crea un nuevo nodo que lleva la memoria libre y empieza despuÃ©s del espacio requerido.</p>
<p>Los nodos se vinculan a la lista tomando en cuenta que el nodo que se encuentra libre fue el primer nodo de la lista, un nodo distinto al inicial o el ultimo nodo de la lista</p>
<p>Memory_list -&gt; La lista que indica las unidades libres de memoria n_units-&gt; Un entero sin signo, corresponde al tamaÃ±o de memoria que quiero solicitar </p>
<dl class="section return"><dt>Devuelve</dt><dd>retorna la funcion void recurrido con los cambios realizados </dd></dl>

<p>Definición en la línea <a class="el" href="../../d7/d4f/src_2physmem_8c_source.html#l00621">621</a> del archivo <a class="el" href="../../d7/d4f/src_2physmem_8c_source.html">physmem.c</a>.</p>

</div>
</div>
<a class="anchor" id="aec0ffbc2b9c56d76912e39c2008bab66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ <a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a>* create_memory_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construye una nueva lista. </p>

</div>
</div>
<a class="anchor" id="ac541ca4737fd15ac73fc4d55907f36a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ <a class="el" href="../../d5/da1/structnode.html">node</a>* create_node </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crea un nuevo nodo. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">El</td><td>estado del nodo L o U </td></tr>
    <tr><td class="paramname">Dirección</td><td>de memoria que representa el Start. </td></tr>
    <tr><td class="paramname">El</td><td>tamaño que tendrá esta memoria libre o usada. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Devuelve el nodo que fue creado. </dd></dl>

</div>
</div>
<a class="anchor" id="ad37fdd7c43e1092a00fe53d8eca2a4f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_region </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permite liberar una región de memoria. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_addr</td><td>Dirección de memoria del inicio de la región a liberar </td></tr>
    <tr><td class="paramname">length</td><td>Tamaño de la región a liberar</td></tr>
  </table>
  </dd>
</dl>
<p>Permite liberar una región de memoria.</p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_addr</td><td>Direccion de memoria del inicio de la regiÃ³n a liberar </td></tr>
    <tr><td class="paramname">length</td><td>TamaÃ±o de la regiÃ³n a liberar </td></tr>
  </table>
  </dd>
</dl>

<p>Definición en la línea <a class="el" href="../../d7/d4f/src_2physmem_8c_source.html#l00401">401</a> del archivo <a class="el" href="../../d7/d4f/src_2physmem_8c_source.html">physmem.c</a>.</p>

</div>
</div>
<a class="anchor" id="a0764342c13c1a182cc07d732f3e5738c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_unit </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>start_dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permite liberar una unidad de memoria. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Dirección de memoria dentro del área a liberar.</td></tr>
  </table>
  </dd>
</dl>
<p>Permite liberar una unidad de memoria.</p>
<p>*En caso contrario, que tamaÃ±o de ptr sea diferente de uno, se crea un nodo auxiliar que iniciara donde comienza ptr ptr el inicio se le aumentara en uno y el tamaÃ±o se le restara en uno, se aumentara las unidades libres, luego tenemos que verificar si el nodo anterior de ptr es o no nulo, para enlazar el n en la lista, dado el caso que la unidad a liberar sea la Ãºltima de la lista o no.</p>
<p>En cada caso se deberÃ¡n unir los nodos libres.</p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">star_dir-&gt;</td><td>recibe la direcciÃ³n que vamos a liberar addr Direcciï¿½n de memoria dentro del ï¿½rea a liberar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definición en la línea <a class="el" href="../../d7/d4f/src_2physmem_8c_source.html#l00351">351</a> del archivo <a class="el" href="../../d7/d4f/src_2physmem_8c_source.html">physmem.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6f2d8be1a11543ee8d99cc03bf77aaba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ <a class="el" href="../../d1/d3a/include_2physmem_8h.html#aeed645bbf6d53327dddcdee4dcc0f427">node_iterator</a> head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Con esta función obtengo el nodo del inicio de la lista. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">La</td><td>lista de la memoria. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>el nodo que se encuenta en el inicio de la lista </dd></dl>

</div>
</div>
<a class="anchor" id="aab6a59fafed2782072f6d7f790e2a61d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ void inicializar_memoria_disponible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Agrega los nodos que representan la memoria disponible en la lista. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">La</td><td>lista enlazada </td></tr>
    <tr><td class="paramname">El</td><td>inicio de la memoria libre. </td></tr>
    <tr><td class="paramname">El</td><td>tamanio que tendrá la memoria libre. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a069f85a5001d71bc44d8be6532a4e432"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kfree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solicita liberar una region de memoria dentro del heap. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Puntero a la base de la region de memoria a liberar </td></tr>
  </table>
  </dd>
</dl>

<p>Definición en la línea <a class="el" href="../../d7/d4f/src_2physmem_8c_source.html#l00433">433</a> del archivo <a class="el" href="../../d7/d4f/src_2physmem_8c_source.html">physmem.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6d6d6d860a3dd67eb762ee84a2a8368c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* kmalloc </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solicita asignacion de memoria dentro del heap. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Tamaño requerido </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Puntero a la base de la region de memoria asignada, 0 si no es posible asignar memoria.</dd></dl>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Tamaï¿½o requerido </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Puntero a la base de la region de memoria asignada, 0 si no es posible asignar memoria. </dd></dl>

<p>Definición en la línea <a class="el" href="../../d7/d4f/src_2physmem_8c_source.html#l00425">425</a> del archivo <a class="el" href="../../d7/d4f/src_2physmem_8c_source.html">physmem.c</a>.</p>

</div>
</div>
<a class="anchor" id="acdef7a1fd863a6d3770c1268cb06add3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void main </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declaración de la función main implementada en physmem.c. </p>

<p>Definición en la línea <a class="el" href="../../d7/d4f/src_2physmem_8c_source.html#l00585">585</a> del archivo <a class="el" href="../../d7/d4f/src_2physmem_8c_source.html">physmem.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac2b96c57dcf1283789c7031f319f7715"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ <a class="el" href="../../d1/d3a/include_2physmem_8h.html#aeed645bbf6d53327dddcdee4dcc0f427">node_iterator</a> next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d3a/include_2physmem_8h.html#aeed645bbf6d53327dddcdee4dcc0f427">node_iterator</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Con esta función obtengo el siguiente a un nodo dado. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">Nodo</td><td>del cual quiero saber cual es su siguiente. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>El nodo Siguiente. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f9ed58c02514095b8afe1320b293fbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ void* pop_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quita el nodo que se encuenta el final de la lista. </p>

</div>
</div>
<a class="anchor" id="afaccb21f57209d357608ab633a27e8bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ void* pop_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quita el nodo que se encuentra al inicio de la lista. </p>

</div>
</div>
<a class="anchor" id="a251f2258231eefe0ad419b73d0fbbba2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ void* push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da1/structnode.html">node</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Agrega un nodo al final de la lista. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">El</td><td>nodo que será agregado en la lista.. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21baf943b2f9352509a531b6206fbd9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ void* push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da1/structnode.html">node</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Agrega un nodo en el frente de la lista. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">La</td><td>lista de la memoria. </td></tr>
    <tr><td class="paramname">El</td><td>nodo que será agregado en la lista. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af711637f21461ed6252595238aa52983"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ unsigned int round_down_to_memory_unit </td>
          <td>(</td>
          <td class="paramtype">addr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Función que redondea una dirección de memoria a la dirección más cercana por debajo que sea múltiplo de MEMORY_UNIT_SIZE. </p>

<p>Definición en la línea <a class="el" href="../../d1/d3a/include_2physmem_8h_source.html#l00021">21</a> del archivo <a class="el" href="../../d1/d3a/include_2physmem_8h_source.html">physmem.h</a>.</p>

</div>
</div>
<a class="anchor" id="a04bb1a508cbed0aa2b632fcbb089c597"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ unsigned int round_up_to_memory_unit </td>
          <td>(</td>
          <td class="paramtype">addr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Función que redondea una dirección de memoria a la dirección más cercana por encima que sea múltiplo de MEMORY_UNIT_SIZE. </p>

<p>Definición en la línea <a class="el" href="../../d1/d3a/include_2physmem_8h_source.html#l00031">31</a> del archivo <a class="el" href="../../d1/d3a/include_2physmem_8h_source.html">physmem.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8950a0a5d1ef2c64d6d99cbb29222803"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setup_memory </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta rutina inicializa el mapa de bits de memoria, a partir de la informacion obtenida del GRUB. </p>
<p>Basicamente lo que se hace es configurar el mapa de bits de la memoria, para ello la secuencia de pasos que realiza dicha configuracion es: </p>
<pre class="fragment">  1.Cargar una estructura de tipo multiboot_info_t con la
   informacion del multiboot que es la informacion que el GRUB
   almacena luego de cargar el KERNEL.
  2.Limpia el mapa de bits, haciendo memory_bitmap[i] = 0,
      donde i=1,2,3.... (memory_bitmap_length-1)
  3.Verifica si el GRUB cargo la informacion solicitada en la
   estructura del multiboot. En el proyecto actual, se omite
   esta parte.
  4.Se establece, la minima direccion de memoria permitida para
   liberar, a esta se le asignara la direccion lineal de donde
   termina el KERNEL.
  5.Verifica si la direccion del mapa de bits son validos, para ello
   verifica que el bit info-&gt;flags[6] sea 1, lo que sifnifica que  mmap_length
   y mmap_addr son validos .
  6.Verifica que la region de memoria cumple con las condiciones
   para ser considerada como Memoria Disponible.
   Para ello, se debe considerar que:
   -&gt;La primera unidad de memoria este ubicada en la posición de
   memoria mayor o igual que 1 MB.
   -&gt;nmap-&gt;type que es el tipo de area de memoria si es 1.
   6,1.Lo que significa disponible, de lo contrario es que ya esta reservada.
    Si la region esta marcada como disponible y la posicion esta por
    encima de la direccion  de la posicion del KERNEL en memora,
    se procede a verificar si el KERNEL se encuentre en esa region.
    Entonces se toma el inicio de la memoria disponible en la posicion
    en la cual finaliza el KERNEL.
    Seguido a esto, se verifica si se cargaron los modulos con el KERNEL
    En caso de que hayan modulos que se carguen con el KERNEL, entonces
    la direccion de posicion inicial cambian ahora y empezadia desde luego
    de los modulos cargado; de lo contrario no se afecta.
    y por ultimo se resta el espacio que ahora dispone.

   6,2.Si la region ya esta reservada, y/o que la primera unidad de memoria
       es menor que 1 MB, lo que significa que el KERNEL no se encuentra en
       esta region, entonces el tamaño es mayor que la region encontrada.

7.Si existe una region de memoria disponible, es decir si la direccion donde
 inicia la primera unidad de memoria es valida, y el tamaño disponible es
 valido.
 Se procede a establecer en que direccion de memoria se debe ubicar para
 la asignacion de memoria permitida a liberar, para esto, se calcula la
 direccion en la cual finaliza la memoria disponibe, hace unos ajustes de
 redondeo, se calcula el tamaño de region disponible con las unidades ya
 redondeadas, y se procede a establecer las variables globales del KERNEL.
8.Se marca la direccion de memoria como disponibley la direccion de memoria
 de la cual se puede liberar memoria.</pre> <p>Existe un mapa de memoria válido creado por GRUB?</p>
<p>Si verifica que el bit en la posición 6 es 1, entonces se crea un mapa valido de memoria, es decir que mmap_length y mmap_addr son validos</p>
<p>Existe un mapa de memoria vï¿½lido creado por GRUB?</p>
<p>Verificar si la regiï¿½n de memoria cumple con las condiciones para ser considerada "memoria disponible".</p>
<p>Importante: Si se supone un procesador de 32 bits, los valores de la parte alta de base y length (base_addr_high y length_high) son cero. Por esta razon se pueden ignorar y solo se usan los 32 bits menos significativos de base y length.</p>
<p>Para que una region de memoria sea considerada "memoria
disponible", debe cumplir con las siguientes condiciones:</p>
<ul>
<li>Estar ubicada en una posicion de memoria mayor o igual que 1 MB.</li>
<li>Tener su atributo 'type' en 1 = memoria disponible.</li>
</ul>

<p>Definición en la línea <a class="el" href="../../de/d99/doc__bitmap_2physmem_8c_source.html#l00067">67</a> del archivo <a class="el" href="../../de/d99/doc__bitmap_2physmem_8c_source.html">physmem.c</a>.</p>

</div>
</div>
<a class="anchor" id="a37faf0202d020fc6220be7d802cb6f04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unirNodosLibres </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d99/structmemory__list.html">memory_list</a> *&#160;</td>
          <td class="paramname"><em>klist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da1/structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>posicionActual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declaración de la función unirNodosLibres implementada en physmem.c. </p>
<p>Declaración de la función unirNodosLibres implementada en physmem.c.</p>
<pre class="fragment">En el siguiente caso se verifica si el nodoAnterior y nodoSiguiente se
encuentran libres, es decir si esta libre a la izquierda o a la derecha.

En este caso quitamos el nodo de la posiciÃ³nActual y el de la derecha.
DespuÃ©s se verifica si el nodoSiguiente del actual, es diferente de nulo;
entonces se procede a quitar el nodoActual y nodosSguiente, para obtener uno
solo con el tamaÃ±o libre.

Ahora con este nuevo nodo se verifica si el nodoAnterior es diferente de  nulo
o se encuentra libre.

Luego se procede a unir estos nuevos nodos y el anterior
serÃ¡ el nuevo Nodo libre con el tamaÃ±o de ambos.

Teniendo encuentra si el nodoSiguiente es o no nulo, con lo que se harÃ¡
los respectivos pasos.

Por lo contrario, si el nodoAnterior es igual a nulo entramos a ver si
el siguiente es diferente de nulo. En este caso, si el nodoSiguiente fue
diferente de nulo y es libre; ademÃ¡s si el siguiente del siguiente fue
diferente de nulo hacemos la asignaciÃ³n del tamaÃ±o al nodo posiciÃ³nActual
uniÃ©ndolo con el nodoSiguiente y libera el nodoSiguiente.

En cambio si el nodoSguiente al siguiente es nulo le asigna al nodo posicionActual
su tamaÃ±o mas el tamaÃ±o del nodoSiguiente y lo coloca al final de la lista;
En el caso que el nodoSiguiente fuera igual a nulo, ya retornarÃ­amos la lista

Luego, si nodoAnterior es diferente de cero, y el estado del nodoAnterior es libre
entramos a preguntar si el estado del nodo siguiente es libre y si es asi verificamos
si el nodoSiguiente del siguiente es nulo. En caso, de ser asÃ­ el tamaÃ±o de la posiciÃ³n
actual serÃ¡ igual al tamaÃ±o de la posicionActual mÃ¡s el tamaÃ±o del nodoSiguiente.

Luego desenlazamos el nodoSiguiente y lo liberamos. En el caso de ser nulo el nodoSiguente al nodoSiguiente,
simplemente le adicionamos el tamaÃ±o de nodoSiguiente al nodo posicionActual y lo ponemos al final de la lista.
</pre><dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">klist-&gt;</td><td>Lista enlazada *posicionActual-&gt; Posicion libre</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>retorna la funciÃ³n void recurrido con los cambios realizados  Ejemplo de 12 Posibles casos que se analizan para liberar unidades de <em>la lista *DONDE: _ : Esta vacio *: Indica que se acaba de liberar U: Indica la existencia de mas nodos L: Indica que el nodo se encuentra Libre _ -L</em>- _ _ -L*- L U -L*- L U -L- L* L* -L- U L -L*- U U -L*-L- U U -L-L*- U U -L-L*- L U -L-L*- L- U L -L*-L- U  </dd></dl>

<p>Definición en la línea <a class="el" href="../../d7/d4f/src_2physmem_8c_source.html#l00744">744</a> del archivo <a class="el" href="../../d7/d4f/src_2physmem_8c_source.html">physmem.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generado por &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
