<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Proyecto 10 - Gestión de Memoria Física: Ensamblador para procesadores IA-32</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Proyecto 10 - Gestión de Memoria Física
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">Aprendiendo Sistemas Operativos</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Buscar');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Página&#160;principal</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Páginas&#160;relacionadas</span></a></li>
      <li><a href="../../modules.html"><span>Módulos</span></a></li>
      <li><a href="../../annotated.html"><span>Estructuras&#160;de&#160;Datos</span></a></li>
      <li><a href="../../files.html"><span>Archivos</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Buscar" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Todo</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Estructuras de Datos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Archivos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Funciones</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>&apos;typedefs&apos;</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>&apos;defines&apos;</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Grupos</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Páginas</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Ensamblador para procesadores IA-32 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Autor</dt><dd>Erwin Meza Vega <a href="#" onclick="location.href='mai'+'lto:'+'eme'+'za'+'v@g'+'ma'+'il.'+'co'+'m'; return false;">emeza<span style="display: none;">.nosp@m.</span>v@gm<span style="display: none;">.nosp@m.</span>ail.c<span style="display: none;">.nosp@m.</span>om</a></dd></dl>
<p><a class="el" href="../../index.html#project_start">Información del Proyecto</a> : <a class="el" href="../../d8/d50/ia32_intro.html">Programación de procesadores de arquitectura IA-32</a> : Ensamblador para IA-32</p>
<p>A continuación se presentan los fundamentos básicos del Lenguaje Ensamblador para procesadores IA-32.</p>
<dl class="section user"><dt>Sintaxis AT&amp;T e Intel en Lenguaje Ensamblador</dt><dd></dd></dl>
<p>Si bien la sintaxis Intel es la más utilizada en la documentación y los ejemplos, es conveniente conocer también los aspectos básicos de la sintaxis AT&amp;T, ya que es la sintaxis por defecto del ensamblador de GNU. Las sintaxis AT&amp;T e Intel difieren en varios aspectos, entre ellos:</p>
<ul>
<li>Nombre de los registros. En sintaxis AT&amp;T los registros (de 16 bits) se denominan: %ax, %bx, %cx, %dx, %si, %di, además de los registros %sp, %bp, y los registros de segmento %cs, %ds, %es, %fs y %gs. Por su parte, en la sintaxis Intel (con la directiva '.intel_syntax noprefix') no es necesario anteponer '' al nombre de los registros.</li>
<li>Orden de los operandos: En la sintaxis AT&amp;T, el orden de los operandos en las instrucciones es el siguiente: <pre class="fragment"> instrucción fuente, destino</pre> Mientras que en la sintaxis Intel, el orden de los operandos es: <pre class="fragment"> instrucción  destino, fuente</pre></li>
<li>Operandos inmediatos. Los operandos inmediatos son aquellos valores que se especifican de forma explícita dentro de la instrucción. En la sintaxis AT&amp;T, los operandos inmediatos se preceden con el signo '$' Por ejemplo, la instrucción en sintaxis AT&amp;T: <pre class="fragment">  movb $0x05, %ah</pre> almacena en el registro ah (un byte) el valor 0x05 (0xXX) significa el número XX en formato hexadecimal). En sintaxis Intel: <pre class="fragment">  mov ah, 0x05</pre></li>
<li>Longitud de operaciones de memoria: En la sintaxis AT&amp;T, cada instrucción debe llevar un sufijo que indica la longitud de la operación de memoria. En sintaxis Intel sólo se debe especificar el sufijo en aquellas instrucciones cuyos operandos son direcciones de memoria o cuando existe ambiguedad en el tamaño de los operandos. Por ejemplo, para mover un byte de una dirección de memoria ds:0x50, al registro AL, el código en sintaxis AT&amp;T sería el siguiente: <pre class="fragment">   movb ds:(0x50), %al</pre> Observe el sufijo 'b' de la instrucción 'mov'. De otro lado, la sintaxis Intel sería la siguiente: <pre class="fragment">   mov al, BYTE PTR ds:[0x50]</pre> También es válida la siguiente sintaxis: <pre class="fragment">   movw al, ds:[addr]</pre> Los sufijos válidos son: b para byte, w para word, l para long (32 bits), y q para quadword (64 bits). Por otra parte, los prefijos de las direcciones de memoria en sintaxis Intel son: BYTE PTR, WORD PTR, DWORD PTR y QWORD PTR.</li>
</ul>
<h1><a class="anchor" id="implicit_segments"></a>
Referencia implícita a los registros de segmento</h1>
<p>Recuerde que sin importar el modo de operación del procesador, siempre se usa segmentación. Así que las direcciones de memoria especificadas en una instrucción de ensamblador siempre serán relativas al inicio de un segmento. Las instrucciones de movimiento de datos (mov, lods, stos, etc) siempre harán referencia implícita al segmento de datos apuntado por el registro de segmento DS. Las instrucciones de salto siempre harán uso implícito del registro de segmento CS, y las operaciones sobre la pila (push, pop) o sobre los registros ESP y EBP siempre harán referencia al segmento apuntado por el registro SS.</p>
<p>En algunas instrucciones es posible cambiar el registro de segmento al cual se hace referencia de forma implícita.</p>
<p>Por ejemplo, la instrucción</p>
<pre class="fragment">mov al, [addr]
</pre><p>Es interpretada por el procesador como </p>
<pre class="fragment">mov al, ds:[addr]
</pre><p>Y la instrucción </p>
<pre class="fragment">movsw
</pre><p>Es intepretada por el procesador como: </p>
<pre class="fragment">  mov word ptr es:[di], word ptr ds:[si]
  inc si
  inc di
</pre><p>Así es necesario revisar la documentación de las instrucciones de ensamblador para determinar si es necesario especificar de forma explícita el registro de segmento.</p>
<h1><a class="anchor" id="operand_size"></a>
Tamaño de los operandos</h1>
<p>El uso de las instrucciones de ensamblador depende en gran medida del tipo de programa que se desea desarrollar. Si se planea desarrollar un programa para ser ejecutado en un entorno de 16 bits (Modo Real), solo se puede tener acceso a los 16 bits menos significativos de los registros, y a un conjunto limitado de instrucciones.</p>
<p>Por el contrario, si se planea desarrollar un programa para ser ejecutado en un entorno de modo protegido de 32 (o 64) bits, se puede tener acceso a la totalidad de bits de los registros y a un conjunto mayor de instrucciones.</p>
<p>La mayoría de instrucciones presentadas a continuación realizan operaciones a nivel de bytes (por ello tienen el sufijo ‘b’), y para el acceso a memoria se utiliza BYTE PTR para indicar apuntadores a bytes. También es posible operar a nivel de words (2 bytes, 16 bits), usando el sufijo ‘w’ y el modificador WORD PTR en vez de BYTE PTR para apuntadores de tipo word en memoria en sintaxis Intel.</p>
<p>En modo de 32 bits, es posible operar sobre doublewords (4 bytes, 32 bits) usando el sufijo ‘w’, y para instrucciones de acceso a memoria se utiliza en sintaxis Intel se debe especificar DWORD PTR en vez de BYTE PTR, o usar el sufijo ‘l’ en la instrucción mov. En operaciones de 64 bits se debe usar el sufijo ‘q’ (quadword, 8 bytes, 64 bits) para la mayoría de instrucciones y QWORD PTR para el acceso a memoria en sintaxis Intel.</p>
<p>Se debe recordar que el uso de los registros depende del modo de operación del procesador. Así, en modo real se puede tener acceso a los primeros de 8 bits y 16 bits de los registros de propósito general, en modo protegido se puede acceder a los 32 bits de los registros y en modo de 64 bits se puede tener acceso a los 64 bits de los registros.</p>
<h1><a class="anchor" id="data_movement"></a>
Movimiento de datos</h1>
<h2><a class="anchor" id="mov_instruction"></a>
INSTRUCCIÓN mov (move)</h2>
<p>Permite mover (copiar) datos entre dos registros, de un valor inmediato a un registro o de un valor inmediato a una posición de memoria.</p>
<dl class="section user"><dt>En sintaxis AT&amp;T</dt><dd></dd></dl>
<dl class="section user"><dt>De inmediato a registros</dt><dd></dd></dl>
<pre class="fragment">movb $0x10, %ah /* Mover el byte (valor inmediato) 0x10 a %ah */
movb $0x20, %al /* Mover el byte 0x20 a %al */
movw $0x1020, %ax /* Mueve un word (2 bytes) a %ax */
movl $0x00001020, %eax /* Mueve un doubleword (4 bytes) a %eax */
movq $0x000000000001020, %rax /* Mueve un quadword (8 bytes) a %rax */
</pre><dl class="section user"><dt>De registros a registros</dt><dd></dd></dl>
<pre class="fragment">movb %al, %bl /* Mover un byte de %al a %bl */
movb %ah, %bh  /* Mover un byte de %ah a %bh */
movw %ax, %bx /* Equivalente a las dos instrucciones anteriores */
movl %eax, %ebx /* 32 bits */
movw %rax, %rbx /* 64 bits */
</pre><dl class="section user"><dt>De registros a memoria</dt><dd></dd></dl>
<pre class="fragment">movb %al, (%si) /* Mover el byte almacenado en %al a la posición 
   de memoria  apuntada por %si */
movb %al, 4(%si) /* Mover el byte almacenado en %al a la posición 
de memoria apuntada por (%si + 4)*/
movb %al, -2(%si) /* Mover el byte almacenado en %al a la posición 
   de memoria apuntada por (%si - 2) */
movw %ax, (%si) /* Mover el word almacenado en %ax a la posición
 de memoria  apuntada por %si */
movl %eax, (%esi) /* 32 bits */ 
movq %rax, (%rsi) /* 64 bits */
</pre><dl class="section user"><dt>De memoria a registros</dt><dd></dd></dl>
<pre class="fragment">movb (%si), %al  /* Mover el byte de la posición de memoria
 apuntada por (%si) a %al */
movb 4($si), %al /* Mover el byte de la posición de memoria 
   apuntada por (%si + 4) a %al */ 
movb -2($si), %al /* Mover el byte de la posición de memoria
 apuntada por (%si - 2) a %al */</pre><dl class="section user"><dt>En sintaxis Intel</dt><dd></dd></dl>
<p>El orden de los operandos es instrucción destino, fuente</p>
<dl class="section user"><dt>De inmediato a registros</dt><dd></dd></dl>
<pre class="fragment">mov ah, 0x10 /* Mover el byte (valor inmediato) 0x10 a ah */
mov al, 0x20 /* Mover el byte 0x20 a al */
mov ax, 0x1020 /* Equivalente a las dos operaciones anteriores */
mov eax, 0x00001020 /* 32 bits */
mov rax, 0x0000000000001020 /* 64 bits */
</pre><dl class="section user"><dt>De registros a registros</dt><dd></dd></dl>
<pre class="fragment">mov bl, al /* Mover un byte de al a bl */
mov bh, ah  /* Mover un byte de ah a bh */
mov bx, ax /* Equivalente a las dos instrucciones anteriores */
mov ebx, eax /* 32 bits */
mov rbx, rax /* 64 bits */
</pre><dl class="section user"><dt>De registros a memoria</dt><dd></dd></dl>
<pre class="fragment">mov BYTE PTR [ si ], al /* Mover el byte almacenado en al a la 
    posicion de memoria apuntada por si */
movb [ si ], al      /* Equivalente a la instrucción anterior. 
      Observe el sufijo ‘w’ en la instrucción. */

mov BYTE PTR [ si + 4 ], al /* Mover el byte almacenado en %al a 
   la posición de memoria apuntada por (si + 4)*/
       
mov BYTE PTR [ si - 2 ], al /* Mover el byte almacenado en %al a 
la posición de memoria apuntada por (si - 2) */

mov WORD PTR [ si ], ax /* Mover el word almacenado en ax a la
posición de memoria apuntada por (si) */  

mov DWORD PTR [ esi ], eax /* 32 bits */ 
mov QWORD PTR [ rsi ], rax /* 64 bits */ 
</pre><dl class="section user"><dt>De memoria a registros</dt><dd></dd></dl>
<pre class="fragment">mov al, BYTE PTR [ si ]   /* Mover el byte de la posición de 
memoria apuntada por (si) a %al */
movw al, [ si ]   /* Equivalente a la instrucción anterior */

mov al, BYTE PTR [ si + 4] /* Mover el byte de la posición de 
memoria apuntada por (si + 4) a al */ 

mov al, BYTE PTR [ si - 2 ] /* Mover el byte de la posición de 
memoria apuntada por (si - 2) a al */

mov ax, WORD PTR [ si ]   /* Mover un word */
mov eax, DWORD PTR [ esi ]   /* 32 bits (doubleword)*/
mov rax, QWORD PTR [ rsi ]   /* 64 bits (quadword) */
</pre><dl class="section user"><dt>INSTRUCCIÓN movs (move string)</dt><dd></dd></dl>
<p>Permite copiar datos entre dos posiciones de memoria. Automáticamente incrementa los dos apuntadores, luego de la copia (Ver <a class="el" href="../../d8/d4b/ia32_assembly_basics.html#repetitions">Repeticiones</a>).</p>
<dl class="section user"><dt>En sintaxis AT&amp;T</dt><dd></dd></dl>
<pre class="fragment">movsb (%si), (%di) /* Copia un byte de la posición de memoria apuntada  por el registro %si a la posición de memoria apuntada por el registro %di */
movsw (%si), (%di) /* Copia un word de (%si) a (%di) */
movsl (%esi), (%edi) /* Copia un dobuleword de (%esi) a (%edi) */
movsq (%rsi), (%rdi) /* Copia un quadword de (%esi) a (%edi) */
</pre><dl class="section user"><dt>En sintaxis Intel</dt><dd></dd></dl>
<pre class="fragment">mov BYTE PTR  [ si ], BYTE PTR [ di ] /* Mueve un byte de (si) a (di)*/
movb [ si ], [ di ] /* Equivalente a la instrucción anterior */
mov WORD PTR [ si ], WORD PTR [ di ] /* Mueve un word de (si) a (di) */
mov DWORD PTR [ esi ], DWORD PTR [ esi ] /* 32 bits */
mov QWORD PTR [ rsi ], QWORD PTR [ rdi ] /* 64 bits */
</pre><dl class="section user"><dt>INSTRUCCIÓN lods (load string)</dt><dd></dd></dl>
<p>Permite copiar datos entre una posición de memoria y un registro. Automáticamente incrementa el apuntador a la memoria en el número de bytes de acuerdo con la longitud de operación.</p>
<dl class="section user"><dt>En sintaxis AT&amp;T</dt><dd></dd></dl>
<pre class="fragment">lodsb /* También es valido lodsb %al, (%si) */
/* Almacena un byte de la posición de memoria apuntada por (%si)en en el registro %al */
  
lodsw /* Almacena un word de la posición de memoria apuntada por 
 (%si) en el registro %ax */

lodsl /* 32 bits */

lodsq /* 64 bits */
</pre><dl class="section user"><dt>En sintaxis Intel</dt><dd></dd></dl>
<pre class="fragment">lods al, BYTE PTR [ si ]
/* Almacena un byte de la posición de memoria apuntada por (si) en  el registro al */
lodsb    /* Equivalente a la instrucción anterior.
La sintaxis abreviada también es válida */
  
lods ax, WORD PTR [ si ] /* Almacena un word de la posición de
memoria apuntada por (si) en el registro ax */
lodsw   /* Equivalente a la instrucción anterior. */

lodsl /* 32 bits */

lodsq /* 64 bits */</pre><dl class="section user"><dt>INSTRUCCIÓN stos (store string)</dt><dd></dd></dl>
<p>Permite copiar datos entre un registro y una posición de memoria. Incrementa automáticamente el apuntador a la memoria.</p>
<dl class="section user"><dt>En sintaxis AT&amp;T</dt><dd></dd></dl>
<pre class="fragment">stosb /* También es valido stosb %al, (%di) */
/* Almacena el valor de %al a la posición de memoria apuntada por (%di)  */
stosw /* Almacena el valor de %ax a la posición de memoria
 apuntada por (%di) */

stosl /* 32 bits */

stosq /* 64 bits */
</pre><dl class="section user"><dt>En sintaxis Intel</dt><dd></dd></dl>
<pre class="fragment">stos BYTE PTR [ di ], al
   /* Almacena el valor de al a la posición de memoria 
  apuntada por   (di) */

stosb   /* También es válida la instrucción abreviada */
  
stos WORD PTR [ di ], ax  /* Almacena el valor de ax a la posición 
de memoria apuntada por  (di) */
stosw  /* Equivalente a la instrucción anterior. */

stosl /* 32 bits */

stosq /* 64 bits */
</pre><h2><a class="anchor" id="repetitions"></a>
Repeticiones</h2>
<p>Las instrucciones movs, lods y stos pueden hacer uso del prefijo 'rep' (repeat), para repetir la operación incrementando los registros ESI o EDI sea el caso y la longitud de la operación, mientras el valor del registro ECX sea mayor que cero. El valor de ECX debe ser establecido antes de invocar la instrucción.</p>
<p>Por ejemplo, las secuencias de instrucciones en sintaxis AT&amp;T (modo real):</p>
<pre class="fragment">movw $0x100, %cx 
rep stosb /* 16 bits, copiar byte a byte, incrementar %di en 1*/

movw $0x80, %cx 
rep stosw /* 16 bits, copiar word a word, incrementar %di en 2 */
</pre><p>en sintaxis Intel:</p>
<pre class="fragment">mov cx, 0x100
rep stosb BYTE PTR [ di ], al /* 16 bits, copiar byte a byte */

mov cx, 0x80
rep stosw WORD PTR [ di ], ax /* 16 bits, copiar word a word */</pre><p>Copian el valor del registro AL (un byte) o AX (dos bytes) a la posición de memoria apuntada por ES:(DI), y automáticamente incrementa el apuntador DI. Cada vez que se ejecuta la instrucción, el registro CX se decrementa y se compara con cero. Los cuatro ejemplos realizan la misma acción en modo real: permiten copiar 256 bytes de un registro a la memoria.</p>
<p>En la primera forma se realizan 256 iteraciones (0x100) para copiar byte a byte, y en la segunda solo se requieren 128 iteraciones (0x80), ya que cada vez se copia un word (dos bytes) cada vez.</p>
<dl class="section user"><dt>Dirección de incremento</dt><dd></dd></dl>
<p>Se debe tener en cuenta que las instrucciones lods, stos y movs automáticamente incrementan los registros ESI o EDI según sea el caso y la longitud de la operación (byte, word, doubleword o quadword).</p>
<p>Esto se puede garantizar invocando la instrucción cld (clear direction flag) con la cual se realiza el incremento automáticamente.</p>
<p>Por el contrario, la instrucción std (set direction flag) causa que las instrucciones decrementen automáticamente los registros ESI o EDI según sea el caso.</p>
<h2><a class="anchor" id="jumps_and_loops"></a>
Saltos, bifurcaciones y ciclos</h2>
<p>Al ejecutar el programa, el procesador simplemente recupera (fetch) la siguiente instrucción apuntada por el registro EIP, la decodifica (decode) y la ejecuta (execute). Luego continúa con la siguiente instrucción. A esto se le denomina el ciclo 'fetch-decode-execute'. No obstante, en los programas de alto nivel generalmente existen instrucciones que permiten alterar la ejecución de un programa de acuerdo con determinadas condiciones, y repetir una serie de instrucciones dentro de ciclos.</p>
<h2><a class="anchor" id="jumps"></a>
Saltos</h2>
<p>Para evitar la linealidad de la ejecución, el procesador dispone de instrucciones que permiten 'saltar' (cambiar el valor de EIP), para poder continuar la ejecución del programa en otro sitio diferente dentro del código. A continuación se describe de forma resumida las instrucciones más usadas para realizar saltos dentro del código.</p>
<dl class="section user"><dt>Instrucción jmp (jump)</dt><dd></dd></dl>
<p>Salto incondicional. Permite continuar la ejecución de forma incondicional en otra posición de memoria, designada generalmente por una etiqueta en el código fuente ensamblador.</p>
<p>Ejemplo (En sintaxis AT&amp;T e Intel ):</p>
<pre class="fragment">label1:
 ...
(instrucciones)
...
jmp label2
(xxxinstruccionesxxx)
...
label2:
...
(instrucciones)
...
</pre><p> En este ejemplo, las instrucciones desde jmp label2 hasta la etiqueta label2 no son ejecutadas. Esto es especialmente útil si se requiere ‘saltar’ una región del código en ensamblador.</p>
<p>En los programas jmp generalmente se salta dentro del mismo segmento. No obstante, si programa lo requiere, es posible saltar a otros segmentos.</p>
<dl class="section user"><dt>Saltos entre segmentos</dt><dd></dd></dl>
<p>El formato de la instrucción JMP para salto entre segmentos es la siguiente:</p>
<p>En sintaxis AT&amp;T:</p>
<pre class="fragment">ljmp seg, offset
</pre><p>En sintaxis Intel: </p>
<pre class="fragment">ljmp seg:offset
</pre><p> En estos formatos de jmp, CS adquiere el valor especificado en 'seg' y EIP adquiere el valor especificado en 'offset'.</p>
<p>Un ejemplo clásico consiste en el salto inicial que debe realizar un sector de arranque, para garantizar que el registro de segmento CS contenga el valor de 0x7C0. Si bien la BIOS siempre carga al sector de arranque en la Dirección lineal 0x7C00, es necesario establecer CS explícitamente en 0x7C0 para que apunte al inicio del segmento de código del sector de arranque cargado en memoria.</p>
<p>Esto se logra mediante la siguiente estructura de código:</p>
<pre class="fragment">start:
   ljmp 0x7C0 : OFFSET entry_point


entry_point: /* La ejecución continúa en este punto, pero CS = 0x7C0. */
   .. demás instrucciones
   
   
   ..
   
   jmp finished
   
finished: /* Ciclo infinito dentro del código del sector de arranque */
   jmp finished </pre><dl class="section user"><dt>Instrucciones de salto condicional </dt><dd></dd></dl>
<p>Instrucciones jz, jnz, je, jne, jle, jge, jc. Estas instrucciones generalmente vienen precedidas por instrucciones que realizan manipulación de registros o posiciones de memoria, y que alteran el contenido del registro EFLAGS (alguno o varios de sus bits).</p>
<p>La sintaxis de todas estas instrucciones es la misma: </p>
<pre class="fragment"> jX label
</pre><p> donde <b>X</b> es la condición que se debe cumplir para realizar el salto.</p>
<p>Algunos ejemplos del uso de las instrucciones de salto condicional son: </p>
<pre class="fragment">jz label
jnz label
je label
</pre><p>Con estas instrucciones se realiza un salto a la etiqueta <b>label</b> en el código ensamblador, dependiendo si se cumple o no la condición de acuerdo con la instrucción. Si la condición no se cumple, el procesador continúa ejecutando la siguiente instrucción que se encuentre después de la instrucción de salto condicional.</p>
<p>Las instrucciones y condiciones más importantes son:</p>
<ul>
<li>jz / je label (jump if zero / jump if equal): Saltar a la etiqueta <b>label</b> si el bit ZF del registro EFLAGS se encuentra en 1, o si en una comparación inmediatamente anterior los operandos a comparar son iguales.</li>
<li>jnz / jne label (jump if not zero / jump if not equal): Contrario a jz. Saltar a la etiqueta label si el bit ZF del registro EFLAGS se encuentra en 0, o si en una comparación inmediatamente anterior los operandos a comparar no son iguales.</li>
<li>jc label: Saltar a la etiqueta label si el bit CF del registro FLAGS se encuentra en 1. Este bit se activa luego de que se cumplen determinadas condiciones al ejecutar otras instrucciones, tales como sumas con números enteros. Igualmente algunos servicios de DOS o de la BIOS establecen el bit CF del registro FLAGS en determinadas circunstancias.</li>
<li>jnc label: Contrario a jc. Saltar a la etiqueta si el bit CF del registro EFLAGS se encuentra en 0.</li>
</ul>
<dl class="section user"><dt>Saltos condicionales y comparaciones</dt><dd></dd></dl>
<p>Uno de los usos más comunes de las instrucciones de salto condicional es comparar si un operando es mayor o menor que otro para ejecutar código diferente de acuerdo con el resultado. Para ello, las instrucciones de salto condicional van precedidas de instrucciones de comparación: </p>
<pre class="fragment">cmp fuente, destino  /*(AT&amp;T)*/
</pre><p>ó </p>
<pre class="fragment">cmp destino, fuente  /* (Intel) */</pre><p>Otras instrucciones de salto condicional que también se pueden utilizar para números con signo son:</p>
<ul>
<li>jg label: jump if greater: Saltar a la etiqueta label si la comparación con signo determinó que el operando de destino es mayor que el operando de fuente</li>
<li>jl label: jump if less: Saltar a la etiqueta label si la comparación encontró que el operando de destino es menor que el operando de fuente</li>
<li>jge label: Jump if greater of equal: Saltar a la etiqueta label si el operando de destino es mayor o igual que el operando de fuente</li>
<li>jle: Jump if less or equal : Saltar a la etiqueta label si el operando de destino es menor o igual que el operando fuente.</li>
</ul>
<dl class="section user"><dt>EJEMPLOS</dt><dd></dd></dl>
<p>En el siguiente ejemplo se almacena el valor inmediato 100 en el registro AL y luego se realiza una serie de comparaciones con otros valores inmediatos y valores almacenados en otros registros.</p>
<p>En sintaxis AT&amp;T: </p>
<pre class="fragment">  movb $100, %al /* A los valores inmediatos en decimal  no se les antepone '0x'
        como a los hexa*/
  cmpb $50, %al /* Esta instrucción compara el valor de %al  con 50 */
  jg es_mayor
  /* Otras instrucciones, que se ejecutan si el valor de %al no es mayor que 50
   (en este caso no se ejecutan, %al = 100 &gt; 50 */
  jmp continuar
 /* Este salto es necesario, ya que de otro modo el procesador 
  ejecutará las instrucciones anteriores y las siguientes 
  también, lo cual es un error de lógica*/
  es_mayor:
   /*  La ejecución continua aquí si el valor de %al (100) es mayor  que 50*/
  continuar:
     /*  Fin de la comparación. El código de este punto hacia 
  Abajo se ejecutará para cualquier valor de %al */
</pre><p>En sintaxis Intel: </p>
<pre class="fragment">    mov al, 100  /* A los valores inmediatos en decimal  no se les antepone '0x'
                 como a los hexa*/
  cmpb al, 50 /* Esta instrucción compara el valor de %al  con  50*/
  jg es_mayor
  /* Otras instrucciones, que se ejecutan si el valor de %al no es mayor que 50 
   (en este caso no se ejecutan, %al = 100 &gt; 50 */
  jmp continuar
 /* Este salto es necesario, ya que de otro modo el procesador 
  ejecutará las instrucciones anteriores y las siguientes 
  también, lo cual es un error de lógica*/
  es_mayor:
 /*  La ejecución continua aquí si el valor de %al (100) es mayor  que 50*/
  continuar:
  /*  Fin de la comparación. El código de este punto hacia 
  Abajo se ejecutará para cualquier valor de %al */</pre><h2><a class="anchor" id="loops"></a>
Ciclos</h2>
<p>Los ciclos son un componente fundamental de cualquier programa, ya que permiten repetir una serie de instrucciones un número determinado de veces. Existen varias formas de implementar los ciclos. Las dos formas más acostumbradas son:</p>
<ol type="1">
<li>Combinar un registro que sirve de variable, una comparación de este registro y una instrucción de salto condicional para terminar el ciclo</li>
<li>Usar la instrucción loop y el registro CX. Este registro no se puede modificar dentro del cuerpo del ciclo.</li>
</ol>
<p>A continuación se ilustran los dos casos. En ciclos más avanzados, las condiciones son complejas e involucran el valor de una o más variables o registros.</p>
<p>El pseudocódigo es el siguiente:</p>
<pre class="fragment">  cx = N
+-&gt; ciclo:
|  si cx = 0
|   goto fin_ciclo
| (Demás instrucciones del ciclo)  
| decrementar cx  
|_goto ciclo
fin_ciclo:
Instrucciones a ejecutar luego del ciclo
</pre><dl class="section user"><dt>Implementación usando a cx como contador y realizando la comparación</dt><dd></dd></dl>
<p>En sintaxis AT&amp;T: </p>
<pre class="fragment">movw $10, %cx /* Para el ejemplo, repetir 10 veces */
ciclo:
cmpw $0, %cx /* Comparar %cx con cero*/
je fin_ciclo /* Si %cx = 0, ir a la etiqueta fin_ciclo */
/* Demás instrucciones del ciclo */
decw %cx /* %cx = %cx - 1 */
jmp ciclo /* salto incondicional a la etiqueta ciclo*/
fin_ciclo:
/* Instrucciones a ejecutar después del ciclo */
</pre><p>En sintaxis Intel: </p>
<pre class="fragment">mov cx, 10 /* Para el ejemplo, repetir 10 veces */
ciclo:
cmp cx, 0 /* Comparar cx con cero*/
je fin_ciclo /* Si cx = 0, ir a la etiqueta fin_ciclo */
/* Demás instrucciones del ciclo */
dec cx /* cx = cx - 1 */
jmp ciclo /* salto incondicional a la etiqueta ciclo*/
fin_ciclo:
/* Instrucciones a ejecutar después del ciclo */
</pre><dl class="section user"><dt>Implementación usando la instrucción loop y el registro cx</dt><dd></dd></dl>
<p>En sintaxis AT&amp;T: </p>
<pre class="fragment">  movw $10, %cx /* Para el ejemplo, repetir 10 veces */
  ciclo:
   /* Demás instrucciones dentro del ciclo 
   Importante: Recuerde que para el ciclo, se utiliza el registro %cx. 
    Por esta razón no es aconsejable utilizarlo dentro del ciclo. */
   
  loop ciclo /* Decrementar automáticamente %cx y verificar si es 
   mayor  que cero. Si %cx es mayor que cero, saltar 
   a la  etiqueta 'ciclo'. En caso contrario, 
   continuar la ejecución en la instrucción 

   siguiente*/   </pre><p>En sintaxis Intel: </p>
<pre class="fragment"> mov cx, 10 /* Para el ejemplo, repetir 10 veces */  
 ciclo:
   /* Demás instrucciones dentro del ciclo 
   Importante: Recuerde que para el ciclo, se usa el registro cx. 
   Por esta razón no se debe utilizar dentro del ciclo.
   */   
loop ciclo /* Decrementar automáticamente cx y verificar si es
 mayor que cero. Si cx es mayor que cero, saltar a la 
 etiqueta 'ciclo' En caso contrario, continuar la 
 ejecución en la instrucción siguiente*/</pre><p>Ambas estrategias son válidas. Generalmente se utiliza la instrucción 'loop' y el registro CX. Sin embargo, cuando la condición es más compleja, se utiliza la primera aproximación.</p>
<dl class="section see"><dt>Ver también</dt><dd><a class="el" href="../../d0/d4f/ia32_execution_environment.html">Entorno de ejecución en IA-32</a> </dd>
<dd>
<a class="el" href="../../da/de6/ia32_using_the_stack.html">Uso de la Pila en IA-32</a> </dd>
<dd>
<a class="el" href="../../d5/d02/ia32_using_routines.html">Creación y uso de rutinas</a> </dd>
<dd>
<a class="el" href="../../d1/db1/ia32_using_bios_services.html">Uso de los servicios de la BIOS</a> </dd>
<dd>
<a class="el" href="../../d3/d4c/ia32_operation_modes.html">Modos de Operación de procesadores IA-32</a> </dd>
<dd>
<a class="el" href="../../d4/de9/ia32_memory_organization.html">Organización de Memoria en Procesadores IA-32</a> </dd>
<dd>
<a class="el" href="../../d0/d4f/ia32_execution_environment.html">Entorno de ejecución en IA-32</a> </dd>
<dd>
<a class="el" href="../../d0/dec/protected_mode_setup.html">Paso a Modo Protegido en Procesadores IA-32</a> </dd>
<dd>
<a class="el" href="../../d8/dfe/gdt_page.html">Tabla Global de Descriptores - GDT</a> </dd>
<dd>
<a href="http://www.gnu.org/software/grub/">http://www.gnu.org/software/grub/</a> Página oficial de GRUB (Enlace externo) </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generado por &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
